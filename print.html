<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">Introduction</a></li><li><a href="01-installation-instructions/README.html"><strong>1.</strong> Installation instructions</a></li><li><ul class="section"><li><a href="01-installation-instructions/linux.html"><strong>1.1.</strong> Linux</a></li><li><a href="01-installation-instructions/windows.html"><strong>1.2.</strong> Windows</a></li><li><a href="01-installation-instructions/macos.html"><strong>1.3.</strong> macOS</a></li></ul></li><li><a href="02-meet-your-hardware/README.html"><strong>2.</strong> Meet your hardware</a></li><li><a href="03-verify-the-installation/README.html"><strong>3.</strong> Verify the installation</a></li><li><a href="04-led-roulette/README.html"><strong>4.</strong> LED roulette</a></li><li><ul class="section"><li><a href="04-led-roulette/build-it.html"><strong>4.1.</strong> Build it</a></li><li><a href="04-led-roulette/flash-it.html"><strong>4.2.</strong> Flash it</a></li><li><a href="04-led-roulette/debug-it.html"><strong>4.3.</strong> Debug it</a></li><li><a href="04-led-roulette/the-led-and-delay-modules.html"><strong>4.4.</strong> The <code>led</code> and <code>delay</code> modules</a></li><li><a href="04-led-roulette/the-challenge.html"><strong>4.5.</strong> The challenge</a></li><li><a href="04-led-roulette/my-solution.html"><strong>4.6.</strong> My solution</a></li></ul></li><li><a href="05-hello-world/README.html"><strong>5.</strong> Hello, world!</a></li><li><ul class="section"><li><a href="05-hello-world/panic.html"><strong>5.1.</strong> <code>panic!</code></a></li></ul></li><li><a href="06-registers/README.html"><strong>6.</strong> Registers</a></li><li><ul class="section"><li><a href="06-registers/rtrm.html"><strong>6.1.</strong> RTRM</a></li><li><a href="06-registers/optimization.html"><strong>6.2.</strong> (mis)Optimization</a></li><li><a href="06-registers/bad-address.html"><strong>6.3.</strong> <code>0xBAAAAAAD</code> address</a></li><li><a href="06-registers/spooky-action-at-a-distance.html"><strong>6.4.</strong> Spooky action at a distance</a></li><li><a href="06-registers/type-safe-manipulation.html"><strong>6.5.</strong> Type safe manipulation</a></li></ul></li><li><a href="07-leds-again/README.html"><strong>7.</strong> LEDs, again</a></li><li><ul class="section"><li><a href="07-leds-again/power.html"><strong>7.1.</strong> Power</a></li><li><a href="07-leds-again/configuration.html"><strong>7.2.</strong> Configuration</a></li></ul></li><li><a href="08-clocks-and-timers/README.html"><strong>8.</strong> Clocks and timers</a></li><li><ul class="section"><li><a href="08-clocks-and-timers/for-loop-delays.html"><strong>8.1.</strong> <code>for</code> loop delays</a></li><li><a href="08-clocks-and-timers/nop.html"><strong>8.2.</strong> NOP</a></li><li><a href="08-clocks-and-timers/one-shot-timer.html"><strong>8.3.</strong> One-shot timer</a></li><li><a href="08-clocks-and-timers/initialization.html"><strong>8.4.</strong> Initialization</a></li><li><a href="08-clocks-and-timers/busy-waiting.html"><strong>8.5.</strong> Busy waiting</a></li><li><a href="08-clocks-and-timers/putting-it-all-together.html"><strong>8.6.</strong> Putting it all together</a></li></ul></li><li><a href="09-serial-communication/README.html"><strong>9.</strong> &quot;Serial&quot; communication</a></li><li><ul class="section"><li><a href="09-serial-communication/nix-tooling.html"><strong>9.1.</strong> *nix tooling</a></li><li><a href="09-serial-communication/windows-tooling.html"><strong>9.2.</strong> Windows tooling</a></li><li><a href="09-serial-communication/loopbacks.html"><strong>9.3.</strong> Loopbacks</a></li></ul></li><li><a href="10-usart/README.html"><strong>10.</strong> USART</a></li><li><ul class="section"><li><a href="10-usart/send-a-single-byte.html"><strong>10.1.</strong> Send a single byte</a></li><li><a href="10-usart/send-a-string.html"><strong>10.2.</strong> Send a string</a></li><li><a href="10-usart/buffer-overrun.html"><strong>10.3.</strong> Buffer overrun</a></li><li><a href="10-usart/uprintln.html"><strong>10.4.</strong> <code>uprintln!</code></a></li><li><a href="10-usart/receive-a-single-byte.html"><strong>10.5.</strong> Receive a single byte</a></li><li><a href="10-usart/echo-server.html"><strong>10.6.</strong> Echo server</a></li><li><a href="10-usart/reverse-a-string.html"><strong>10.7.</strong> Reverse a string</a></li><li><a href="10-usart/my-solution.html"><strong>10.8.</strong> My solution</a></li></ul></li><li><a href="11-bluetooth-setup/README.html"><strong>11.</strong> Bluetooth setup</a></li><li><ul class="section"><li><a href="11-bluetooth-setup/linux.html"><strong>11.1.</strong> Linux</a></li><li><a href="11-bluetooth-setup/loopback.html"><strong>11.2.</strong> Loopback</a></li><li><strong>11.3.</strong> AT commands</li></ul></li><li><a href="12-serial-over-bluetooth/README.html"><strong>12.</strong> Serial over Bluetooth</a></li><li><a href="13-i2c/README.html"><strong>13.</strong> I2C</a></li><li><ul class="section"><li><a href="13-i2c/the-general-protocol.html"><strong>13.1.</strong> The general protocol</a></li><li><a href="13-i2c/lsm303dlhc.html"><strong>13.2.</strong> LSM303DLHC</a></li><li><a href="13-i2c/read-a-single-register.html"><strong>13.3.</strong> Read a single register</a></li><li><a href="13-i2c/the-solution.html"><strong>13.4.</strong> The solution</a></li><li><a href="13-i2c/read-several-registers.html"><strong>13.5.</strong> Read several registers</a></li></ul></li><li><a href="14-led-compass/README.html"><strong>14.</strong> LED compass</a></li><li><ul class="section"><li><a href="14-led-compass/take-1.html"><strong>14.1.</strong> Take 1</a></li><li><a href="14-led-compass/solution-1.html"><strong>14.2.</strong> Solution 1</a></li><li><a href="14-led-compass/take-2.html"><strong>14.3.</strong> Take 2</a></li><li><a href="14-led-compass/solution-2.html"><strong>14.4.</strong> Solution 2</a></li><li><a href="14-led-compass/magnitude.html"><strong>14.5.</strong> Magnitude</a></li><li><a href="14-led-compass/calibration.html"><strong>14.6.</strong> Calibration</a></li></ul></li><li><a href="15-punch-o-meter/README.html"><strong>15.</strong> Punch-o-meter</a></li><li><ul class="section"><li><a href="15-punch-o-meter/gravity-is-up.html"><strong>15.1.</strong> Gravity is up?</a></li><li><a href="15-punch-o-meter/the-challenge.html"><strong>15.2.</strong> The challenge</a></li><li><a href="15-punch-o-meter/my-solution.html"><strong>15.3.</strong> My solution</a></li></ul></li><li><a href="16-async-io-the-future/README.html"><strong>16.</strong> Async IO: The future</a></li><li><ul class="section"><li><a href="16-async-io-the-future/timer.html"><strong>16.1.</strong> Timer</a></li><li><a href="16-async-io-the-future/serial.html"><strong>16.2.</strong> Serial</a></li><li><a href="16-async-io-the-future/the-challenge.html"><strong>16.3.</strong> The challenge</a></li><li><a href="16-async-io-the-future/my-solution.html"><strong>16.4.</strong> My solution</a></li><li><a href="16-async-io-the-future/another-challenge.html"><strong>16.5.</strong> Another challenge</a></li><li><a href="16-async-io-the-future/my-other-solution.html"><strong>16.6.</strong> My other solution</a></li><li><a href="16-async-io-the-future/more-challenges.html"><strong>16.7.</strong> More challenges</a></li></ul></li><li><a href="explore.html">What's left for you to explore</a></li><li class="spacer"></li><li class="affix">Appendix</li><li class="affix"><a href="appendix/1-general-troubleshooting/README.html">General troubleshooting</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1><a href="http://www.rust-belt-rust.com/">Rust Belt Rust 2016</a></h1>
<blockquote>
<p>[Workshop] Bare metal: Programming ARM microcontrollers in Rust</p>
</blockquote>
<blockquote>
<p><strong>IMPORTANT</strong> This the material I presented at the Rust Belt Rust conference
in October of 2016. For historical reasons, this page will remain unchanged.
If you are interested in a continuation of this material check my
<a href="https://japaric.github.io/discovery">Discovery</a> book.</p>
</blockquote>
<h2>What's a microcontroller?</h2>
<p>A microcontroller is a <em>system</em> on a chip. Whereas your laptop is made up of
several discrete components: a processor, RAM sticks, a hard drive, an ethernet
port, etc.; a microcontroller has all those components built into a single
&quot;chip&quot; or package. This makes it possible to build systems with minimal part
count.</p>
<h2>What can you do with a microcontroller?</h2>
<p>Lots of things! Microcontrollers are the central part of systems known as
<em>embedded</em> systems. These systems are everywhere but you can't usually tell that
they are there. These systems control the brakes of your car, wash your clothes,
print your papers, keep you warm, keep you cool, optimize fuel consumption, etc.</p>
<p>The main trait of these systems is that they operate without user intervention
even if they expose a user interface like a washing machine does most of their
operation is done on their own.</p>
<p>The other common trait of these systems is that they <em>control</em> a process. And
for that these systems usually have one or more sensors and one or more
actuators. For example, an HVAC system has several sensors, thermometers and
humidy sensors spread across some area, and several actuators as well, heating
elements and fans connected to ducts.</p>
<h2>When should I use a microcontroller?</h2>
<p>All these application I've mentioned, you can probably implement with a
Raspberry Pi, a computer that runs Linux. Why should I bother with a
microcontroller that operates without an OS? Sounds like it would be harder to
develop a program.</p>
<p>The main reason is cost. A microcontroller is much cheaper than a general
purpose computer. Not only the microcontroller is cheaper; it also requires much
less external electrical components to operate. This makes Printed Circuit
Boards (PCB) smaller and cheaper to design and manufacture.</p>
<p>The other big reason is power consumption. A microcontroller consumes orders of
magnitude less power than a full blown processor. If your application will
run on batteries that makes a huge difference.</p>
<p>At last but not least: precise timing control. A general purpose computer
running a general purpose OS has many services running in the background. This
makes it hard to guarantee execution of a program within tight time constraints
(microsecond range for instance).</p>
<h2>When should I <em>not</em> use a microcontroller?</h2>
<p>Where heavy computations are involved. To keep their power consumption low,
microcontrollers have very limited computational resources available to them.
For example, some microcontrollers don't even have hardware support for floating
point operations. On those devices, performing a simple addition of single
precision numbers can take hundreds of CPU cycles.</p>
<h2>Why use Rust and not C?</h2>
<p>Hopefully, I don't need to convince you here as you are probably familiar with
the language differences between Rust and C. One point I do want to bring up is
package management. C lacks an official, widely accepted package management
solution whereas Rust has Cargo. This makes development <em>much</em> easier. And, IMO,
easy package management encourages code reuse because libraries can be easily
integrated into an application which is a good thing as libraries get more
&quot;battle testing&quot;.</p>
<h2>Why should I not use Rust?</h2>
<p>Or why should I prefer C over Rust?</p>
<p>The C ecosystem is way more mature. Off the shelf solution for several problems
already exist. If you need to control a time sensitive process, you can grab one
of the existing commercial Real Time Operating Systems (RTOS) out there and
solve your problem. There are no commercial, production-grade RTOSes in Rust yet
so you would have to either create one yourself or try one of the ones that are
in development.</p>
<hr />
<p>Enough marketing. Let's actually build stuff!</p>
<h2>The hardware</h2>
<p>On the day of the workshop, we'll provide you this hardware:</p>
<ul>
<li>A <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> board.</li>
</ul>
<p align="center">
<img title="STM32F3DISCOVERY" src="assets/f3.jpg">
</p>
<ul>
<li><a href="https://www.sparkfun.com/products/9873">This <strong>3.3V</strong> USB &lt;-&gt; Serial module</a> (*)</li>
</ul>
<p>(If you are reading this after the workshop, you can follow this material if you
have a different model.)</p>
<p align="center">
<img title="A 3.3v USB <-> Serial module" src="assets/serial.jpg">
</p>
<ul>
<li>A HC-05 Bluetooth module (with headers!)</li>
</ul>
<p align="center">
<img title="The HC-05 Bluetooth module" src="assets/bluetooth.jpg">
</p>
<ul>
<li>Two mini-B USB cables (preferably at least 50cm (~2ft) long).</li>
</ul>
<p align="center">
<img title="mini-B USB cable" src="assets/usb-cable.jpg">
</p>
<blockquote>
<p><strong>NOTE</strong> These are <strong>not</strong> the USB cables that ship with pretty much every
Android phone; those are <em>micro</em> USB cables. Make sure you have the right
thing!</p>
</blockquote>
<ul>
<li>4 Female/Female, 4 Male/Female and 1 Male/Male jumper wires</li>
</ul>
<p align="center">
<img title="Jumper wires" src="assets/jumper-wires.jpg">
</p>
<h2>Documentation</h2>
<p>This is the documentation we'll refer to during the workshop.</p>
<ul>
<li><a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">STM32F3DISCOVERY User Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">STM32F303VC Datasheet</a></li>
<li><a href="http://www.st.com/resource/en/reference_manual/dm00043574.pdf">STM32F303VC Reference Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">LSM303DLHC</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/l3gd20.pdf">L3GD20</a></li>
</ul>
<h1>Installation I</h1>
<h2>CHANGELOG</h2>
<p>Updates since your last visit:</p>
<ul>
<li>All: Install <a href="01-installation-instructions/README.html#Xargo">Xargo 0.2.0</a> or newer. The installation process is much simpler
on this new version. Do note that with Xargo 0.2.0, it's mandatory to install
the <code>rust-src</code> component using <code>rustup</code>.</li>
<li>Windows: Be sure to install <a href="01-installation-instructions/windows.html#ST-LINK%20USB%20driver">the USB driver for the ST-LINK</a>.</li>
</ul>
<hr />
<p>Let's install a bunch of tools that we'll use during the workshop!</p>
<blockquote>
<p>Please complete these instructions <strong>before</strong> the day of the workshop!</p>
</blockquote>
<p>If you run into any problem while following these instructions, feel free to
open <a href="https://github.com/japaric/rbr2016/issues">an issue</a>, <a href="https://github.com/japaric">shoot me an e-mail</a> or ping me (<code>japaric</code>) on Mozilla's IRC
network (I'm on pretty much every Rust related channel but if you to have pick
one, I'd recommend the #rust-embedded channel).</p>
<p>The Rust Belt Rust organizers have also set up a slack &quot;team&quot; for the attendees
and speakers: <a href="https://rust-belt-rust.slack.com">rust-belt-rust.slack.com</a>. Within that team, there's an
<a href="https://rust-belt-rust.slack.com/messages/embedded-workshop/">#embedded-workshop</a> channel for our use during the workshop. You can also ask
me questions about the installation process over there!</p>
<p>I also recommend subscribing to <a href="https://github.com/japaric/rbr2016">this repository</a> so you get notified of any
change in the installation process.</p>
<h2>Documentation</h2>
<p>Download a copy of the <a href="../#Documentation">documentation</a> and keep them
somewhere handy. We'll refer to them several times during the workshop!</p>
<h2>Tools</h2>
<p>We'll use all the tools listed below. Where a minimum version is not specified,
any recent version should work but we have listed the version we have tested.</p>
<ul>
<li>Cargo &amp; <code>rustc</code>  &gt;= nightly-2016-10-05</li>
<li><a href="https://crates.io/crates/xargo">Xargo</a> &gt;= 0.1.13. But 0.2.x is highly recommended.</li>
<li><a href="https://crates.io/crates/itm"><code>itmdump</code></a> &gt;= 0.1.1</li>
<li>OpenOCD &gt;=0.8. Tested version: 0.9.0</li>
<li><code>arm-none-eabi-gcc</code>. Tested versions: 4.8, 5.2 and 6.2</li>
<li><code>arm-none-eabi-gdb</code>. Version 7.12 or newer highly recommended. Tested
versions: 7.10, 7.11 and 7.12</li>
<li><code>minicom</code> on Linux and macOS. Tested version: 2.7</li>
<li><code>PuTTY</code> on Windows.</li>
</ul>
<p>If the laptop you'll be using for the workshop has Bluetooth, you can
additionally install these tools to play with the Bluetooth module we'll be
providing. All these are optional:</p>
<ul>
<li>Linux, only if you don't have a Bluetooth manager application like Blueman.
<ul>
<li><code>bluez</code></li>
<li><code>hcitool</code></li>
<li><code>rfcomm</code></li>
<li><code>rfkill</code></li>
</ul>
</li>
</ul>
<p>macOS / OSX / Windows users only need the default bluetooth manager that ships
with their OS.</p>
<p>Next, follow OS-agnostic installation instructions for a few of the tools:</p>
<h3><code>rustc</code> &amp; Cargo</h3>
<p>Install rustup by following the instructions at https://rustup.rs.</p>
<p>Then, install or switch to the nightly channel (2016-10-05 or newer)</p>
<pre><code>$ rustup default nightly
</code></pre>
<h3>Xargo</h3>
<p>You can install Xargo in two different ways:</p>
<ul>
<li>By grabbing a <a href="https://github.com/japaric/xargo/releases">binary release</a> and placing it somewhere in your <code>$PATH</code>.
<code>$HOME/.cargo/bin</code> is a good place to install it to. Do make sure that the
binary release you &quot;installed&quot; actually works by executing the following
command:</li>
</ul>
<pre><code>$ xargo -V
xargo 0.2.0 (bd8ebc4 2016-10-16)
cargo 0.13.0-nightly (a8baa5b 2016-10-15)
</code></pre>
<ul>
<li>Or, by building it yourself with the following command:</li>
</ul>
<pre><code>$ cargo install xargo
$ xargo -V
</code></pre>
<p>You will additionally need to install the <code>rust-src</code> component (the source of
the Rust compiler and standard libraries) using <code>rustup</code> because Xargo (v0.2.x)
depends on it:</p>
<pre><code>$ rustup component add rust-src
</code></pre>
<h3><code>itmdump</code></h3>
<pre><code>$ cargo install itm
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Windows users will need to install a version 0.1.1 or newer because
version 0.1.0 doesn't support Windows.</p>
</blockquote>
<h3>OS specific instruction</h3>
<ul>
<li><a href="01-installation-instructions/linux.html">Linux</a></li>
<li><a href="01-installation-instructions/windows.html">Windows</a></li>
<li><a href="01-installation-instructions/macos.html">macOS</a></li>
</ul>
<h1>Linux</h1>
<p>Here are the installation commands for a few Linux distributions.</p>
<h2>REQUIRED packages</h2>
<ul>
<li>Ubuntu 16.04 or newer / Debian Jessie or newer</li>
</ul>
<pre><code>$ sudo apt-get install \
  gcc-arm-none-eabi \
  gdb-arm-none-eabi \
  minicom \
  openocd
</code></pre>
<ul>
<li>Fedora 23 or newer</li>
</ul>
<pre><code>$ sudo dnf install \
  arm-none-eabi-gcc-cs \
  arm-none-eabi-gdb \
  minicom \
  openocd
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<pre><code>$ sudo pacman -S \
  arm-none-eabi-gcc \
  arm-none-eabi-gdb \
  minicom \
  openocd
</code></pre>
<h2>Optional packages</h2>
<ul>
<li>Ubuntu / Debian</li>
</ul>
<pre><code>$ sudo apt-get install \
  bluez \
  rfkill
</code></pre>
<ul>
<li>Fedora</li>
</ul>
<pre><code>$ sudo dnf install \
  bluez \
  rfkill
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<pre><code>$ sudo pacman -S \
  bluez \
  bluez-utils \
  rfkill
</code></pre>
<h2>udev rules</h2>
<p>These rules let you use USB devices like the F3 and the Serial module without
root privilege, i.e. <code>sudo</code>.</p>
<p>Create these two files in <code>/etc/udev/rules.d</code> with the contents shown below.</p>
<pre><code>$ cat /etc/udev/rules.d/99-ftdi.rules
# FT232 - USB &lt;-&gt; Serial Converter
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6001&quot;, GROUP=&quot;uucp&quot;
</code></pre>
<pre><code>$ cat /etc/udev/rules.d/99-openocd.rules
# STM32F3DISCOVERY - ST-LINK/V2.1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;374b&quot;, GROUP=&quot;uucp&quot;
</code></pre>
<p>Then reload the udev rules with:</p>
<pre><code>$ sudo udevadm control --reload-rules
</code></pre>
<p>If you had any board plugged to your laptop, unplug them and then plug them in
again.</p>
<p>Finally, check if you are in the <code>uucp</code> group.</p>
<pre><code>$ groups $(id -nu)
(..) uucp (..)
     ^^^^
</code></pre>
<p>(<code>$(id -nu)</code> returns your user name. In my case it's <code>japaric</code>.)</p>
<p>If <code>uucp</code> appears in the output. You are all set! Go to the <a href="02-meet-your-hardware/README.html">next section</a>.
Otherwise, keep reading:</p>
<ul>
<li>Add yourself to the <code>uucp</code> group.</li>
</ul>
<pre><code>$ sudo usermod -a -G uucp $(id -u -n)
</code></pre>
<ul>
<li>Check again the output of <code>groups</code>. <code>uucp</code> should be there this time!</li>
</ul>
<pre><code>$ groups $(id -nu)
(..) uucp (..)
     ^^^^
</code></pre>
<p>You'll have to re-log for these changes to take effect. You have two options:</p>
<p>You can reboot or log out from your current session and then log in; this will
close all the programs you have open right now.</p>
<p>The other option is to use the command below:</p>
<pre><code>$ su - $(id -nu)
</code></pre>
<p>to re-log <em>only in the current shell</em> and get access to <code>uucp</code> devices <em>only on
that shell</em>. Other shells <em>won't</em> have access to <code>uucp</code> devices unless you
manually re-log on them with the same <code>su</code> command.</p>
<h1>Windows</h1>
<h2><code>arm-none-eabi-*</code></h2>
<p>The GNU ARM Embedded Toolchain project provides <code>.exe</code> installers for Windows.
Grab <a href="https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q3-update/+download/gcc-arm-none-eabi-5_4-2016q3-20160926-win32.exe">this one</a>, and follow the instructions. Just before the installation
process finishes tick/select the &quot;Add path to environment variable&quot; option. Then
verify that the tools are in your <code>%PATH%</code>:</p>
<pre><code>$ arm-none-eabi-gcc -v
(..)
gcc version 5.4.1 20160919 (release) (..)
</code></pre>
<h2>OpenOCD</h2>
<p>There's no official binary release of OpenOCD for Windows but there are
unofficial releases available <a href="http://gnutoolchains.com/arm-eabi/openocd/">here</a>. Grab the 0.9.0 zipfile and extract it
somewhere in your drive (I recommend <code>C:\OpenOCD</code> but with the drive letter that
makes sense to you) then update your <code>%PATH%</code> environment variable to include
the following path: <code>C:\OpenOCD\bin</code> (or the path that you used before).</p>
<p>Verify that OpenOCD is in yout <code>%PATH%</code> with:</p>
<pre><code>$ openocd -v
Open On-Chip Debugger 0.9.0 2015-08-15-12:41 (..)
</code></pre>
<h2>PuTTY</h2>
<p>Download the latest <code>putty.exe</code> from <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">this site</a> and place it somewhere in your
<code>%PATH%</code>.</p>
<h2>ST-LINK USB driver</h2>
<p>You'll also need to install <a href="www.st.com/en/embedded-software/stsw-link009.html">this USB driver</a> or OpenOCD won't work. Follow the
installer instructions and make sure you install the right (32-bit or 64-bit)
version of the driver.</p>
<p>That's all! Go to the <a href="02-meet-your-hardware/README.html">next section</a>.</p>
<h1>macOS</h1>
<p>All the tools can be install using <a href="http://brew.sh/">Homebrew</a>:</p>
<pre><code>$ brew cask install gcc-arm-embedded
$ brew install minicom openocd
</code></pre>
<p>If the <code>brew cask</code> command doesn't work (&quot;Error: Unknown command: cask&quot;), then
run <code>brew tap Caskroom/tap</code> first and try again.</p>
<p>That's all! Go to the <a href="02-meet-your-hardware/README.html">next section</a>.</p>
<h1>Meet your hardware</h1>
<p>Let's get familiar with the hardware we'll be working with.</p>
<h2>STM32F3DISCOVERY (the &quot;F3&quot;)</h2>
<p align="center">
<img title="F3" src="assets/f3.jpg">
</p>
<p>We'll refer to this board as &quot;F3&quot; throughout this workshop.</p>
<p>What does this board contain?</p>
<ul>
<li>A STM32F303VCT6 microcontroller. This microcontroller has
<ul>
<li>A single core ARM Cortex-M4F processor with hardware support for single
precision floating point operations and a maximum clock frequency of 72 MHz.</li>
<li>256 KiB of &quot;Flash&quot; memory. (1 KiB = 10<strong>24</strong> bytes)</li>
<li>48 KiB of RAM.</li>
<li>many &quot;peripherals&quot;: timers, GPIO, I2C, SPI, USART, etc.</li>
<li>lots of &quot;pins&quot; that are exposed in the two lateral &quot;headers&quot;.</li>
</ul>
</li>
</ul>
<p><strong>IMPORTANT</strong> This microcontroller operates at 3.3V.</p>
<ul>
<li>
<p>An accelerometer and a magnetometer (in a single package).</p>
</li>
<li>
<p>A gyroscope.</p>
</li>
<li>
<p>8 user LEDs arranged in the shape of a compass</p>
</li>
<li>
<p>A second microcontroller: a STM32F103CBT. This microcontroller is actually
part of an on-board programmer and debugger named ST-LINK and is connected to
the USB port named &quot;USB ST-LINK&quot;.</p>
</li>
<li>
<p>There's a second USB port, labeled &quot;USB USER&quot; that is connected to the main
microcontroller, the STM32F303VCT6, and can be used in applications.</p>
</li>
</ul>
<h2>The Serial module</h2>
<p align="center">
<img title="Serial module" src="assets/serial.jpg">
</p>
<p>We'll use this module to exchange data between the microcontroller in the F3 and
your laptop. This module will be connected to your laptop using an USB cable. I
won't say more at this point.</p>
<h2>The Bluetooth module</h2>
<p align="center">
<img title="The HC-05 Bluetooth module" src="assets/bluetooth.jpg">
</p>
<p>This module has the exact same purpose as the serial module but it sends the
data over Bluetooth instead of over USB.</p>
<h1>Verify the installation</h1>
<p>You should now have your hardware. Let's verify the installations steps you did
in the <a href="01-installation-instructions/README.html">Installation</a> section.</p>
<h2>Linux only</h2>
<h3>Verify permissions</h3>
<p>Connect the F3 to your laptop using an USB cable. Be sure to connect the cable
to the &quot;USB ST-LINK&quot; port, the middle USB port.</p>
<p>The F3 should now appear as a USB device (file) in <code>/dev/bus/usb</code>. Let's find
out how it got enumerated:</p>
<pre><code>$ lsusb | grep -i stm
Bus 003 Device 004: ID 0483:374b STMicroelectronics ST-LINK/V2.1
    ^^^        ^^^
</code></pre>
<p>In my case, the F3 got connected to the bus #3 and got enumerated as the device
#4. This means the file <code>/dev/bus/usb/003/004</code> <em>is</em> the F3. Let's check its
permissions:</p>
<pre><code>$ ls -l /dev/bus/usb/003/004
crw-rw-r-- 1 root uucp 189, 262 Oct 27 00:00 /dev/bus/usb/003/004
</code></pre>
<p>The group should be <code>uucp</code>. If it's not ... then check your <a href="01-installation-instructions/linux.html#udev%20rules">udev rules</a> and try
re-loading them with:</p>
<pre><code>$ sudo udevadm control --reload-rules
</code></pre>
<p>Now let's repeat the procedure for the Serial module.</p>
<p>Unplug the F3 and plug the Serial module. Now, figure out what's its associated
file:</p>
<pre><code>$ lsusb | grep -i ft232
Bus 003 Device 005: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
</code></pre>
<p>In my case, it's the <code>/dev/bus/usb/003/005</code>. Now, check its permissions:</p>
<pre><code>$ ls -l /dev/bus/usb/003/005
crw-rw-r--+ 1 root uucp 189, 261 Oct 27 00:00 /dev/bus/usb/003/005
</code></pre>
<p>As before, the group should be <code>uucp</code>.</p>
<h2>All</h2>
<h3>First OpenOCD connection</h3>
<p>First, connect the F3 to your laptop using an USB cable. Connect the cable to
the center USB port of the F3, the one that's labeled &quot;USB ST-LINK&quot;.</p>
<p>Two <em>red</em> LEDs should turn on right after connecting the USB cable to the board.</p>
<p>Next, call this command:</p>
<pre><code># *nix
$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg

# Windows
$ openocd -s C:\OpenOCD\share\scripts -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Windows users: <code>C:\OpenOCD</code> is the directory where you installed
OpenOCD to.</p>
</blockquote>
<p>You should see output like this:</p>
<pre><code>Open On-Chip Debugger 0.9.0 (2016-04-27-23:18)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.914184
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>(If you don't ... then check the <a href="appendix/1-general-troubleshooting/README.html">general troubleshooting</a> instructions.)</p>
<p>And OpenOCD will block. That's fine.</p>
<p>Also, one of the red LEDs, the one closest to the USB port, should start
oscillating between red light and green light.</p>
<p>That's it! It works. You can now close/kill OpenOCD.</p>
<h1>LED roulette</h1>
<p>Alright, let's start by building the following application:</p>
<p align="center">
<img src="https://i.imgur.com/0k1r2Lc.gif">
</p>
<p>I'm going to give you a high level API to implement this app but don't worry
we'll do low level stuff later on. The main goal of this chapter is to get
familiar with the &quot;flashing&quot; and debugging process.</p>
<p>Jump into the <code>src/04-led-roulette</code> directory. There's some starter code in it.</p>
<pre><code class="language-rust">#![no_std]
#![no_main]

extern crate pg;

#[export_name = &quot;main&quot;]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let y;
    let x = 42;
    y = x;

    loop {}
}
</code></pre>
<p>There's some unusual stuff in it: <code>#![no_main]</code>, <code>#[export_name]</code> and <code>main</code> is
both <code>pub</code> and has signature <code>fn() -&gt; !</code>. For now, why those are the way they
are doesn't matter. The only practical implication of all this is that you can't
return from the <code>main</code> function.</p>
<p>If you are a careful observer, you'll also notice there is a <code>.cargo</code> directory
in the Cargo project as well. <code>:-)</code></p>
<p>Alright, let's start by building this program.</p>
<h1>Build it</h1>
<p>The first step is to build our &quot;binary&quot; crate. Because the microcontroller has
different architecture than your laptop we'll have to cross compile. Cross
compiling in Rust land is as simple as passing an extra <code>--target</code> flag to
<code>rustc</code>or Cargo. The complicated part is figuring out the argument of that flag:
the <em>name</em> of the target.</p>
<p>The microcontroller in the F3 has a Cortex-M4F processor in it. <code>rustc</code> knows
how to cross compile to the Cortex-M architecture and provides 4 different
targets that cover the different processor families within that architecture:</p>
<ul>
<li><code>thumbv6m-none-eabi</code>, for the Cortex-M0 and Cortex-M1 processors</li>
<li><code>thumbv7m-none-eabi</code>, for the Cortex-M3 processor</li>
<li><code>thumbv7em-none-eabi</code>, for the Cortex-M4 and Cortex-M7 processors</li>
<li><code>thumbv7em-none-eabihf</code>, for the Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> processors</li>
</ul>
<p>For the F3, we'll to use the <code>thumbv7em-none-eabihf</code> target.</p>
<p>Now, <code>rustup</code> doesn't provide a binary release of the <code>core</code> crate for this
target, so we'll use Xargo instead of Cargo. Xargo will take care of compiling
the <code>core</code> crate for us:</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf
   Compiling core v0.0.0 (file://$SYSROOT/lib/rustlib/src/rust/src/libcore)
   Compiling alloc v0.0.0 (file://$SYSROOT/lib/rustlib/src/rust/src/liballoc)
   Compiling rustc_unicode v0.0.0 (file://$SYSROOT/lib/rustlib/src/rust/src/librustc_unicode)
   Compiling collections v0.0.0 (file://$SYSROOT/lib/rustlib/src/rust/src/libcollections)
   Compiling rand v0.0.0 (file://$SYSROOT/lib/rustlib/src/rust/src/librand)
   Compiling f3 v0.2.0
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
   Compiling volatile-register v0.1.2
   Compiling cortex-m v0.2.0
   Compiling compiler-builtins-snapshot v0.0.20161008+c56faf22abb39724008148d58f12bcd43b6d236b
   Compiling pg v0.1.0 (file://$SYSROOT/04-led-roulette/pg)
   Compiling led-roulette v0.1.0 (file://$SYSROOT/04-led-roulette)
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Be sure to compile this crate <em>without</em> optimizations</p>
</blockquote>
<p>Also, let me note that Xargo exposes the exact same UI as Cargo so you can use
any subcommand (even custom ones) that you would normally use with Cargo.</p>
<p>OK, now we have produced an executable. As a sanity check, let's verify that
the produced executable is actually an ARM binary:</p>
<pre><code># *nix only
$ file target/thumbv7em-none-eabihf/debug/led-roulette
led-roulette: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped
                                         ~~~  ~~~~~                   ~~~~~~~~~~~~~~~~~
</code></pre>
<p>Another way to do that is to use <code>readelf</code> because the executable produced by
<code>rustc</code> is actually an ELF (Executable and Linkable Format) file.</p>
<pre><code>$ arm-none-eabi-readelf -h target/thumbv7em-none-eabihf/debug/led-roulette
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM &lt;--
  Version:                           0x1
  Entry point address:               0x8000195 &lt;--
  Start of program headers:          52 (bytes into file)
  Start of section headers:          555816 (bytes into file)
  Flags:                             0x5000400, Version5 EABI, hard-float ABI &lt;--
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         17
  Section header string table index: 14
</code></pre>
<p>Next, we'll &quot;flash&quot; the program into our microcontroller.</p>
<h1>Flash it</h1>
<p>Flashing is the process of moving our program into the microcontroller's
(persistent) memory. Once flashed, the microcontroller will executed the flashed
program everytime is powered on.</p>
<p>In this case, our <code>led-roulette</code> program will be the <em>only</em> program in the
microcontroller memory. By this I mean that there's nothing else running on the
microcontroller: no OS, no &quot;daemon&quot;, nothing. <code>led-roulette</code> has full control
over the device.</p>
<p>Onto the actual flashing. First thing we need is to do is launch OpenOCD.
We did that in the previous section but this time we'll run the command inside a
temporary directory (<code>/tmp</code> on *nix; <code>%TEMP%</code> on Windows).</p>
<p>Make sure the F3 is connected to your laptop and run the following commands on a
new terminal.</p>
<pre><code># *nix
$ cd /tmp

# Windows
$ cd %TEMP%

# Windows: remember that you need an extra `-s %PATH_TO_OPENOCD%\share\scripts`
$ openocd \
  -f interface/stlink-v2-1.cfg \
  -f target/stm32f3x.cfg
</code></pre>
<p>The program will block; leave that terminal open.</p>
<p>Now it's a good time to explain what this command is actually doing.</p>
<p>I mentioned that the F3 actually has two microcontrollers. One of them is used
as a programmer/debugger. The part of the board that's used as a programmer is
called ST-LINK (that's how STMicroelectronics decided to call it). This
&quot;ST-LINK&quot; is connected to the target microcontroller using a Serial Wire Debug
(SWD) interface (this interface is an ARM standard so you'll run into it when
dealing with other Cortex-M based microcontrollers). This SWD interface can be
used to flash and debug a microcontroller. The ST-LINK is connected to the
&quot;USB ST-LINK&quot; port and will appear as an USB device when you connect the F3 to
your laptop.</p>
<p align="center">
<img height=640 title="On-board ST-LINK" src="assets/st-link.png">
</p>
<p>As for OpenOCD. It's a software that provides some services like a <em>GDB server</em>
&quot;on top&quot; of USB devices that expose a debugging protocol like SWD or JTAG.</p>
<p>Onto the actual command: Those <code>.cfg</code> files we are using instruct OpenOCD to
look for a ST-LINK USB device (<code>interface/stlink-v2-1.cfg</code>) and to expect a
STM32F3XX microcontroller (<code>target/stm32f3x.cfg</code>) to be connected to the
ST-LINK.</p>
<p>The OpenOCD output looks like this:</p>
<pre><code>Open On-Chip Debugger 0.9.0 (2016-04-27-23:18)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919073
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>The &quot;6 breakpoints, 4 watchpoints&quot; part indicates the debugging features the
processor has available.</p>
<p>I mentioned that OpenOCD provides a GDB server so let's connect to that right
now:</p>
<pre><code>$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb)
</code></pre>
<p>This only opens a GDB shell. To actually connect to the OpenOCD GDB server, use
the following command within the GDB shell:</p>
<pre><code>(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<p>OpenOCD's GDB server is listening on TCP port 3333 (localhost). This command is
connecting to that port.</p>
<p>After entering this command, you'll see new output in the OpenOCD terminal:</p>
<pre><code class="language-diff"> Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
+Info : accepting 'gdb' connection on tcp/3333
+Info : device id = 0x10036422
+Info : flash size = 256kbytes
</code></pre>
<p>Almost there. To flash the device, we'll use the <code>load</code> command inside the GDB
shell:</p>
<pre><code>(gdb) load
Loading section .text, size 0x6798 lma 0x8000000
Loading section .ARM.extab.text._ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h4f3134c02513b5e1E, size 0xc lma 0x8006798
Loading section .ARM.extab.text._ZN4core3fmt9Formatter11debug_tuple17hf0ed23ebdee33c00E, size 0xc lma 0x80067a4
Start address 0x8000194, load size 26544
Transfer rate: 21 KB/sec, 6636 bytes/write.
</code></pre>
<p>And that's it. You'll also new output under the OpenOCD command.</p>
<pre><code class="language-diff"> Info : flash size = 256kbytes
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+adapter speed: 4000 kHz
+target state: halted
+target halted due to breakpoint, current mode: Thread
+xPSR: 0x61000000 pc: 0x2000003a msp: 0x2000a000
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
</code></pre>
<p>Our program is loaded, let's debug it!</p>
<h1>Debug it</h1>
<p>We are already inside a debugging session so let's debug our program.</p>
<p>After the <code>load</code> command, our program is stopped at its <em>entry point</em>. This is
indicated by the &quot;Start address 0x8000XXX&quot; part of GDB's output. The entry point
is the part of a program that a processor / CPU will execute first.</p>
<p>The starter project I've provided to you has some extra code that runs <em>before</em>
the <code>main</code> function. At this time, we are not interested in that &quot;pre-main&quot;
part so let's skip right to the beginning of the <code>main</code> function. We'll do that
using a breakpoint:</p>
<pre><code>(gdb) break main
Breakpoint 1 at 0x80001e6: file $PWD/src/main.rs, line 9.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, led_roulette::main () at $PWD/src/main.rs:7
7       pub extern &quot;C&quot; fn main() -&gt; ! {
</code></pre>
<p>Breakpoints can be used to stop the normal flow of a program. The <code>continue</code>
command will let the program run free <em>until</em> it reaches a breakpoint. In this
case, until it reaches the <code>main</code> function because there's a breakpoint there.</p>
<p>Note that GDB output says &quot;Breakpoint 1&quot;. Remember that our processor can only
use 6 breakpoints so it's a good idea to pay attention to these messages.</p>
<p>For a nicer debugging experience, we'll be using GDB's Text User Interface
(TUI). To enter into that mode, on the GDB shell enter the following command:</p>
<pre><code>(gdb) layout src
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Apologies Windows users. The GDB shipped with the GNU ARM Embedded
Toolchain doesn't support this TUI mode <code>:-(</code>.</p>
</blockquote>
<p><img src="assets/gdb-layout-src.png" alt="GDB session" title="GDB TUI" /></p>
<p>At any point you can leave the TUI mode using the following command:</p>
<pre><code>(gdb) tui disable
</code></pre>
<p>OK. We are now at the beginning of <code>main</code>. We can advance the program statement
by statement using the <code>step</code> command. So let's use that twice to reach the <code>y = x</code> statement.</p>
<pre><code>(gdb) step
11          let x = 42;

(gdb) step
12          y = x;
</code></pre>
<p>If you are not using the TUI mode, on each <code>step</code> call GDB will print back the
current statement along with its line number.</p>
<p>We are now &quot;on&quot; the <code>y = x</code> statement; that statement hasn't been executed yet.
This means that <code>x</code> is initialized but <code>y</code> is not. Let's inspect those
stack/local variables using the <code>print</code> command:</p>
<pre><code>(gdb) print x
$1 = 42

(gdb) print &amp;x
$2 = (i32 *) 0x20009ff0

(gdb) print y
$3 = 134218195

(gdb) print &amp;y
$4 = (i32 *) 0x20009ff4
</code></pre>
<p>As expected, <code>x</code> contains the value <code>42</code>. <code>y</code>, however, contains the value
<code>134218195</code> (?). Because <code>y</code> is uninitialized, it contains some random value.</p>
<p>The command <code>print &amp;x</code> prints the address of the variable <code>x</code>. The interesting
bit here is that GDB output shows the type of the reference: <code>i32*</code>, a pointer
to an <code>i32</code> value. Another interesting thing is that the addresses of <code>x</code> and
<code>y</code> are very close to each other: just off by <code>4</code>.</p>
<p>Instead of printing the local variables one by one, you can also use the <code>info locals</code> command:</p>
<pre><code>(gdb) info locals
x = 42
y = 134218195
</code></pre>
<p>OK. With another <code>step</code>, we'll be on top of the <code>loop {}</code> statement:</p>
<pre><code>(gdb) step
13          loop {}
</code></pre>
<p>And <code>y</code> should now be initialized.</p>
<pre><code>(gdb) print y
$5 = 42
</code></pre>
<p>If we use <code>step</code> again on top of the <code>loop {}</code> statement, we'll get stuck
because the program will never pass that statement. Instead, we'll switch to the
disassemble view with the <code>layout asm</code> command and advance one instruction at a
time using <code>stepi</code>.</p>
<blockquote>
<p><strong>NOTE</strong> If you used the <code>step</code> command by mistake and GDB got stuck, you can
unstuck it by hitting <code>Ctrl+C</code>.</p>
</blockquote>
<pre><code>(gdb) layout asm
</code></pre>
<p><img src="assets/gdb-layout-asm.png" alt="GDB session" title="GDB disassemble" /></p>
<p>If you are not using the TUI mode, you can use the <code>disassemble /m</code> command to
disassemble the program around the line you are currently at.</p>
<pre><code>(gdb) disassemble /m
Dump of assembler code for function led_roulette::main:
9       pub extern &quot;C&quot; fn main() -&gt; ! {
   0x080001e6 &lt;+0&gt;:     sub     sp, #12
   0x080001e8 &lt;+2&gt;:     b.n     0x80001ea &lt;led_roulette::main+4&gt;

10          let y;
11          let x = 42;
   0x080001ea &lt;+4&gt;:     movs    r0, #42 ; 0x2a
   0x080001ec &lt;+6&gt;:     str     r0, [sp, #4]

12          y = x;
   0x080001ee &lt;+8&gt;:     str     r0, [sp, #8]

13
14          loop {}
=&gt; 0x080001f0 &lt;+10&gt;:    b.n     0x80001f2 &lt;led_roulette::main+12&gt;
   0x080001f2 &lt;+12&gt;:    b.n     0x80001f2 &lt;led_roulette::main+12&gt;

End of assembler dump.
</code></pre>
<p>See the arrow <code>=&gt;</code>? It shows the instruction the processor will execute next.</p>
<p>If not inside the TUI mode, on each <code>stepi</code> command GDB will print the
statement, the line number <em>and</em> the address of the instruction the processor
will execute next.</p>
<pre><code>(gdb) stepi
0x080001f2      13          loop {}

(gdb) stepi
0x080001f2      13          loop {}
</code></pre>
<p>One last trick before we move to something more interesting. Enter the following
commands into GDB:</p>
<pre><code>(gdb) monitor reset halt
Unable to match requested speed 1000 kHz, using 950 kHz
Unable to match requested speed 1000 kHz, using 950 kHz
adapter speed: 950 kHz
target state: halted
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000

(gdb) continue
Continuing.

Breakpoint 1, led_roulette::main () at $PWD/src/main.rs:7
7       pub extern &quot;C&quot; fn main() -&gt; ! {
</code></pre>
<p>We are now back at the beginning of <code>main</code>!</p>
<p><code>monitor reset halt</code> will reset the microcontroller and stop it right at the
program entry point. The following <code>continue</code> command will let the program run
freely until it reaches the <code>main</code> function that has a breakpoint on it.</p>
<p>This combo is handy when you, by mistake, skipped over a part of the program
that you were interested in inspecting. You can easily roll back the state of
your program back to its very beginning.</p>
<blockquote>
<p><strong>The fine print</strong>: This <code>reset</code> command doesn't clear or touch RAM. That
memory will retain its values from the previous run. That shouldn't be a
problem tough, unless your program behavior depends of the value of
<em>uninitialized</em> variables but that's the definition of Undefined Behavior
(UB).</p>
</blockquote>
<p>We are done with this debug session. You can end it with the <code>quit</code> command.</p>
<pre><code>(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: $PWD/target/thumbv7em-none-eabihf/debug/led-roulette, Remote target
Ending remote debugging.
</code></pre>
<p>Don't close OpenOCD though! We'll use it again and again later on. It's better
just to leave it running.</p>
<p>What's next? The high level API I promised.</p>
<h1>The <code>led</code> and <code>delay</code> modules</h1>
<p>Now, I'm going to introduce two high level modules that we'll use to implement
the LED roulette application.</p>
<p>The Playground crate, <code>pg</code>, exposes the <code>delay</code> and <code>led</code> modules.</p>
<p>The <code>delay</code> module exposes a <code>ms</code> function that can block your program for <code>n</code>
milliseconds.</p>
<p>The <code>led</code> modules exposes a <code>LEDS</code> static variable that holds 8 <code>Led</code> <code>struct</code>s
in an array. Each <code>Led</code> struct represents an LED on the F3 board and exposes two
methods: <code>on</code> and <code>off</code> which can be used to turn the LED on or off,
respectively.</p>
<p>Let's try out this API by modifying the starter code to look like this:</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_std]
#![no_main]

extern crate pg;

use pg::delay;
use pg::led::LEDS;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let half_period = 500; // ms

    loop {
        LEDS[0].on();
        delay::ms(half_period);

        LEDS[0].off();
        delay::ms(half_period);
    }
}
</code></pre>
<p>Now build it:</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf
</code></pre>
<blockquote>
<p><strong>NOTE</strong> It's quite common to forget to rebuild the program <em>before</em> starting
a GDB session. This omission can lead to very confusing debug sessions. Always
make sure to call <code>xargo build</code> <strong>before</strong> calling <code>gdb</code>.</p>
</blockquote>
<p>Now, we'll have to repeat the flashing procedure that we did in the previous
section:</p>
<pre><code>$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb) target remote :3333
Remote debugging using :3333
(..)

(gdb) load
Loading section .text, size 0x76c8 lma 0x8000000
Loading section .ARM.extab.text._ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h4f3134c02513b5e1E, size 0xc lma 0x80076c8
Loading section .ARM.extab.text._ZN4core3fmt9Formatter11debug_tuple17hf0ed23ebdee33c00E, size 0xc lma 0x80076d4
Start address 0x8000194, load size 30432
Transfer rate: 22 KB/sec, 7608 bytes/write.

(gdb) break main
Breakpoint 1 at 0x80001e6: file /home/japaric/rust/rbr2016/src/04-led-roulette/src/main.rs, line 10.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, led_roulette::main () at /home/japaric/rust/rbr2016/src/04-led-roulette/src/main.rs:10
10      pub extern &quot;C&quot; fn main() -&gt; ! {
</code></pre>
<p>OK. Let's step through the code. This time, we'll use the <code>next</code> command instead
of <code>step</code>. The difference is that the <code>next</code> command will step <em>over</em> function
calls instead of going inside them.</p>
<pre><code>(gdb) next
13          let half_period = 500; // ms

(gdb) next
15          loop {

(gdb) next
16              LEDS[0].on();

(gdb) next
17              delay::ms(half_period);
</code></pre>
<p>After executing the <code>LEDS[0].on()</code> statement, you should see a red LED, the one
&quot;pointing North&quot;, turn on.</p>
<p>Let's continue stepping over the program:</p>
<pre><code>(gdb) next
19              LEDS[0].off();

(gdb) next
20              delay::ms(half_period);
</code></pre>
<p>The <code>delay::ms</code> call will block the program for half a second but you may not
notice because the <code>next</code> command also takes some time to execute. However,
after stepping over the <code>LEDS[0].off()</code> statement you should see the red LED
turn off.</p>
<p>You can already guess what this program does. Let it run uninterrupted using the
<code>continue</code> command.</p>
<pre><code>(gdb) continue
Continuing.
</code></pre>
<p>Now, let's do something more interesting. We are going to modify the behavior of
our program using GDB.</p>
<p>First, let's stop the infinite loop by hitting <code>Ctrl+C</code>. You'll probably end up
somewhere inside <code>Led::on</code>, <code>Led::off</code> or <code>delay::ms</code>:</p>
<pre><code>Program received signal SIGINT, Interrupt.
0x08000d04 in core::ptr::read_volatile&lt;u32&gt; (src=0x40001410)
    at $SYSROOT/lib/rustlib/src/rust/src/libcore/ptr.rs:213
213     pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T {
(gdb)
</code></pre>
<p>In my case, the program stopped its execution inside a <code>read_volatile</code> function.
GDB output shows some interesting information about that:
<code>core::ptr::read_volatile&lt;u32&gt; (src=0x40001410)</code>. This means that: the function
comes from the <code>core</code> crate, it's originally a generic function but we are
dealing with a <code>u32</code> instance of it and that it was called with argument <code>src = 0x40001410</code>.</p>
<p>Just so you know, a more explicit way to show the arguments of a function is to
use the <code>info args</code> command:</p>
<pre><code>(gdb) info args
src = 0x40001410
</code></pre>
<p>Regardless of where your program may have stopped you can always look at output
of the <code>backtrace</code> command to learn how you got there:</p>
<pre><code>(gdb) backtrace
#0  0x08000d04 in core::ptr::read_volatile&lt;u32&gt; (src=0x40001410)
    at $SYSROOT/lib/rustlib/src/rust/src/libcore/ptr.rs:213
#1  0x08004280 in volatile_register::RW&lt;u32&gt;::read&lt;u32&gt; (self=&lt;optimized out&gt;)
    at $VOLATILE_REGISTER/src/lib.rs:71
#2  f3::peripheral::tim::Sr::read (self=0x40001410)
    at $F3/master/src/peripheral/tim.rs:321
#3  0x080014d6 in f3::delay::ms (n=500) at $F3/master/src/delay.rs:23
#4  0x08000210 in led_roulette::main () at $PWD/src/main.rs:15
</code></pre>
<p><code>backtrace</code> will print back a trace of function calls that lead to the current
program state.</p>
<p>Back to our topic. To do what we are after, first, we have to return to the
<code>main</code> function. We can do that using the <code>finish</code> command. This command resumes
the program execution and stops it again right after the program returns from
the current function. We'll have to call it several times.</p>
<pre><code>(gdb) finish
Run till exit from #0  0x08000d04 in core::ptr::read_volatile&lt;u32&gt; (src=0x40001410)
    at $SYSROOT/lib/rustlib/src/rust/src/libcore/ptr.rs:213
f3::peripheral::tim::Sr::read (self=0x40001410)
    at $F3/master/src/peripheral/tim.rs:321
321             SrR { bits: self.register.read() }
Value returned is $1 = 0

(gdb) finish
Run till exit from #0  f3::peripheral::tim::Sr::read (self=0x40001410)
    at $F3/src/peripheral/tim.rs:321
0x080014d6 in f3::delay::ms (n=500) at $F3/src/delay.rs:23
23              while !tim7.sr.read().uif() {}
Value returned is $2 = f3::peripheral::tim::SrR {bits: 0}

(gdb) finish
Run till exit from #0  0x080014d6 in f3::delay::ms (n=500)
    at $F3/src/delay.rs:23
0x08000210 in led_roulette::main () at $PWD/src/main.rs:15
15              delay::ms(half_period);
</code></pre>
<p>We are back in <code>main</code>. We have a local variable in here: <code>half_period</code></p>
<pre><code>(gdb) info locals
half_period = 500
</code></pre>
<p>Now, we are going to modify this variable using the <code>set</code> command:</p>
<pre><code>(gdb) set half_period = 100

(gdb) print half_period
$1 = 100
</code></pre>
<p>If you let program run free again using the <code>continue</code> command, you should see
that the LED will blink at a much faster rate now!</p>
<p>Question! What happens if you keep lowering the value of <code>half_period</code>? At what
value of <code>half_period</code> you can no longer see the LED blink?</p>
<p>Now, it's your turn to write a program.</p>
<h1>The challenge</h1>
<p>You are now well armed to face a challenge! Your task will be to implement the
application I showed you at the beginning of this chapter.</p>
<p>Here's the GIF again:</p>
<p align="center">
<img src="assets/led-roulette.gif">
</p>
<p>Also, this may help:</p>
<p align="center">
<img src="assets/timing-diagram.png">
</p>
<p>This is a timing diagram. It indicates which LED is on at any given instant of
time and for how long each LED should be on. On the X axis we have the time in
milliseconds. The timing diagram shows a single period. This pattern will repeat
itself every 800 ms. The Y axis labels each LED with a cardinal point: North,
East, etc. As part of the challenge you'll have to figure out how each element
in the <code>LEDS</code> array maps to these cardinal points (hint: <code>cargo doc --open</code>
<code>;-)</code>).</p>
<p>Before you attempt this challenge. Let me give you one last tip. Our GDB
sessions always involve entering the same commands at the beginning. We can use
a <code>.gdbinit</code> file to execute some commands right after GDB is started. This way
you can save yourself the effort of having to enter them manually on each GDB
session.</p>
<p>Place this <code>.gdbinit</code> file at the root of the Cargo project, right next to the
<code>Cargo.toml</code>:</p>
<pre><code>target remote :3333
load
break main
continue
</code></pre>
<p>With that in place, you should now be able to start a <code>gdb</code> session that will
automatically flash the program and jump to the beginning of <code>main</code>:</p>
<pre><code>$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(..)
Loading section .text, size 0x2014 lma 0x8000000
Start address 0x8000194, load size 8212
Transfer rate: 15 KB/sec, 8212 bytes/write.
Breakpoint 1 at 0x80001e6: file $PWD/src/main.rs, line 12.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, led_roulette::main () at $PWD/src/main.rs:12
12      pub extern &quot;C&quot; fn main() -&gt; ! {
(gdb)
</code></pre>
<p>But if that doesn't work and, instead, you get this:</p>
<pre><code>$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
warning: File &quot;$PWD/.gdbinit&quot; auto-loading has been declined by your `auto-load safe-path' set to &quot;$debugdir:$datadir/auto-load&quot;.
To enable execution of this file add
        add-auto-load-safe-path $PWD/.gdbinit
line to your configuration file &quot;$HOME/.gdbinit&quot;.
To completely disable this security protection add
        set auto-load safe-path /
line to your configuration file &quot;$HOME/.gdbinit&quot;.
For more information about this security protection see the
&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:
        info &quot;(gdb)Auto-loading safe path&quot;
</code></pre>
<p>You'll have to do a few extra steps. It's definitively worth it though.</p>
<h2>*nix</h2>
<p>This command should do the trick.</p>
<pre><code>$ echo 'set auto-load safe-path /' &gt; ~/.gdbinit
</code></pre>
<p>The project local <code>.gdbinit</code> should work now.</p>
<h2>Windows</h2>
<p>AFAIK, Windows doesn't set a <code>%HOME%</code> env variable by default so you'll have to
add that variable to your environment first. I recommend you set it to
<code>%USERPROFILE%</code> (e.g. <code>C:\Users\japaric</code>).</p>
<p>Then you have to create a <code>.gdbinit</code> file in <code>%HOME%</code> (e.g.
<code>C:\Users\japaric\.gdbinit</code>) with these contents:</p>
<pre><code>set auto-load safe-path /
</code></pre>
<p>The project local <code>.gdbinit</code> should work now.</p>
<h1>My solution</h1>
<p>What solution did you come up with?</p>
<p>Here's mine:</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate pg;

use core::iter;

use pg::delay;
use pg::led::LEDS;

#[export_name = &quot;main&quot;]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        for (current, next) in LEDS.iter()
            .zip(LEDS.iter().skip(1).chain(iter::once(&amp;LEDS[0]))) {
            next.on();
            delay::ms(50);
            current.off();
            delay::ms(50);
        }
    }
}
</code></pre>
<p>One more thing! Check that your solution also works when compiled in &quot;release&quot;
mode:</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf --release
</code></pre>
<p>You can test it with this <code>gdb</code> command:</p>
<pre><code>$ arm-none-eabi-gdb target/thumbv7em-none-eabihf/release/led-roulette
                                                 ~~~~~~~
</code></pre>
<p>Binary size is something we should always keep an eye on! How big is your
solution? You can check that using the <code>size</code> command on the &quot;release&quot; binary:</p>
<pre><code>$ arm-none-eabi-size target/thumbv7em-none-eabihf/release/led-roulette
   text    data     bss     dec     hex filename
   1006       0       0    1006     3ee target/thumbv7em-none-eabihf/release/led-roulette
</code></pre>
<blockquote>
<p><strong>NOTE</strong> The Cargo project is already configured to build the release binary
using LTO.</p>
</blockquote>
<p>Know how to read this output? The <code>text</code> section contains the program
instructions. It's around one thousand bytes in my case. OTOH, the <code>data</code> and
<code>bss</code> sections contain variables statically allocated in RAM (<code>static</code>
variables). I'm not using any so the sizes of these sections are zero.</p>
<p>One final thing! We have been running our programs from within GDB but our
programs don't depend on GDB at all. You can confirm this be closing both GDB
and OpenOCD and then resetting the board by pressing the black button on the
board. The LED roulette application will run without intervention of GDB.</p>
<h1>Hello, world!</h1>
<p>(Just a little more of helpful &quot;magic&quot; before we start doing low level stuff.)</p>
<p>Blinking an LED is like the &quot;Hello, world&quot; of the embedded world.</p>
<p>But in this section, we'll run a proper &quot;Hello, world&quot; program that prints stuff
to the console.</p>
<p>Go to the <code>05-hello-world</code> directory. There's some starter code in it:</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_std]
#![no_main]

#[macro_use]
extern crate pg;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    iprintln!(&quot;Hello, world!&quot;);

    loop {}
}
</code></pre>
<p>The <code>iprintln</code> macro will format messages and output them to the
microcontroller's <em>ITM</em>. ITM stands for Instrumentation Trace Macrocell and it's
a communication protocol on top of SWD (Serial Wire Debug) which can be used to
send messages from the microcontroller to the debugging host. This communication
is only &quot;one way&quot; as the debugging host can't send data to the microcontroller.</p>
<p>OpenOCD, which is managing the debug session, can receive data sent through this
&quot;ITM channel&quot; and redirect it to a file.</p>
<p>The ITM protocol works with &quot;frames&quot; (you can think of them as ethernet
packets). Each frame has a header and a variable length payload. OpenOCD will
receive these frames and write them directly to a file without parsing them. So,
if the microntroller sends the string &quot;Hello, world!&quot; using the <code>iprintln</code>
macro, OpenOCD's output file won't exactly contain that string.</p>
<p>To retrieve the original string, OpenOCD's output file will have to be parsed.
We'll use the <code>itmdump</code> program to perform the parsing &quot;on the fly&quot;.</p>
<p>You should have already installed the <code>itmdump</code> program during the <a href="01-installation-instructions/README.html#itmdump">installation
chapter</a>.</p>
<p>In a new terminal, run this command inside the <code>/tmp</code> directory, if you are
using a *nix OS, or from within the <code>%TEMP%</code> directory, if you are running
Windows. This should be the same directory from where you are running OpenOCD.
It's very important that both <code>itmdump</code> and <code>openocd</code> are running from the same
directory!</p>
<pre><code># *nix
$ cd /tmp

# Windows
$ cd %TEMP%

$ itmdump itm.txt
</code></pre>
<p>This command will block as <code>itmdump</code> is now &quot;watching&quot; the <code>itm.txt</code> file. Leave
this terminal open.</p>
<p>Alright. Now, let's build the starter code and flash it into the
microcontroller.</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf
</code></pre>
<p>Note that there's a <code>.gdbinit</code> at the root of the Cargo project. It's the same
one we used in the previous section.</p>
<pre><code>$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/hello-world
Reading symbols from target/thumbv7em-none-eabihf/debug/hello-world...done.
(..)
Start address 0x8000194, load size 11682
Transfer rate: 18 KB/sec, 5841 bytes/write.
Breakpoint 1 at 0x80001e6: file $PWD/src/main.rs, line 10.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, hello_world::main () at $PWD/src/main.rs:10
10      pub extern &quot;C&quot; fn main() -&gt; ! {
</code></pre>
<p>Before we execute the <code>iprintln!</code> statement. We have to instruct OpenOCD to
redirect the ITM output into the same file that <code>itmdump</code> is watching.</p>
<pre><code>(gdb) monitor tpiu config internal itm.txt uart off 8000000
</code></pre>
<p>All should be ready! Now execute the <code>iprintln!</code> statement.</p>
<pre><code>(gdb) next
11          iprintln!(&quot;Hello, world!&quot;);

(gdb) next
13          loop {}
</code></pre>
<p>You should see some output in <code>itmdump</code>'s terminal:</p>
<pre><code># itmdump's terminal
Hello, world!
</code></pre>
<p>Awesome, right? Feel free to use <code>iprintln</code> as a logging tool in the coming
sections.</p>
<p>The <code>iprint!</code> macros are not the only thing that's wired to the ITM. <code>:-)</code></p>
<h1><code>panic!</code></h1>
<p>The <code>panic!</code> macro also sends its output to the ITM!</p>
<p>Change the <code>main</code> function to look like this:</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    panic!(&quot;Hello, world!&quot;)
}
</code></pre>
<p>Let's try this program. But before that let's update <code>.gdbinit</code> to run that
<code>monitor tpiu</code> for us at startup:</p>
<pre><code>target remote :3333
load
monitor tpiu config internal itm.txt uart off 8000000
break main
continue
</code></pre>
<pre><code>$ xargo build --target thumbv7em-none-eabihf

$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/hello-world
(..)

(gdb) next
11          panic!(&quot;Hello, world!&quot;)
(gdb) next

Program received signal SIGTRAP, Trace/breakpoint trap.
f3::lang_items::panic_fmt (msg=..., file=..., line=11)
    at $F3/src/lang_items.rs:12
12          bkpt!();

(gdb) _
</code></pre>
<p>You'll see some new output in <code>itmdump</code>'s terminal.</p>
<pre><code># itmdump's terminal
PANIC at 'Hello, world!', src/main.rs:11
</code></pre>
<p>You won't get a <code>RUST_BACKTRACE</code> style backtrace in <code>itmdump</code>'s output, <em>but</em>
you can get the equivalent inside GDB. You already know the command:</p>
<pre><code>(gdb) backtrace
#0  f3::lang_items::panic_fmt (msg=..., file=...,
    line=10)
    at $F3/src/lang_items.rs:12
#1  0x0800193c in core::panicking::panic_fmt::h54fc4ef0e431f1de ()
#2  0x080018d4 in core::panicking::panic::h2a0ea99cd46c9ef6 ()
#3  0x080001f8 in hello_world::main ()
    at $PWD/src/main.rs:10
</code></pre>
<p>Ultimately, <code>panic!</code> is just another function call so you can see it leaves
behind a trace of function calls.</p>
<p>Something other interesting thing happened when we hit the <code>panic!</code> but you may
have missed it. Let's re-run the program but this time let's use <code>continue</code>
instead of <code>next</code>:</p>
<pre><code>(gdb) monitor reset halt
target state: halted
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000

(gdb) continue
Continuing.

Breakpoint 1, hello_world::main () at $PWD/src/main.rs:10
10      pub extern &quot;C&quot; fn main() -&gt; ! {
</code></pre>
<p>We are back in <code>main</code>, let's <code>continue</code>:</p>
<pre><code>(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
f3::lang_items::panic_fmt (msg=..., file=..., line=11)
    at $F3/src/lang_items.rs:12
12          bkpt!();
</code></pre>
<blockquote>
<p>Program received signal SIGTRAP, Trace/breakpoint trap.</p>
</blockquote>
<p>The program hit a breakpoint! But we didn't set one in GDB. What happened here
is that <code>panic!</code> called the <code>bkpt!()</code> macro and that <code>bkpt!</code> macro <em>is</em> a
breakpoint in the form of an instruction. <code>bkpt!()</code> actually expands to
<code>asm!(&quot;bkpt&quot;)</code> and <code>bkpt</code> is the breakpoint instruction on ARM Cortex-M devices.</p>
<p>Remember that our microcontroller only supports 6 breakpoints? Well, <code>bkpt!()</code>
<em>doesn't</em> count towards that limit of 6. Only breakpoints set in GDB using the
<code>break</code> command count towards that limit. So, feel free to use the <code>bkpt!</code>
instruction in your programs from now on. You'll have to wrap it in <code>unsafe</code> and
add <code>#![feature(asm)]</code> to your crate tough because the <code>asm!</code> syntax extension
is unstable.</p>
<p>As a final note: Although very useful, ITM is not meant to be used in
<em>production</em>. It requires too many components (an extra microcontroller!)
because it can only be used when the microcontroller is attached to a debugger.</p>
<p>Later on, we'll see other simpler communication protocols.</p>
<h1>Registers</h1>
<blockquote>
<p><strong>TODO</strong> IMPORTANT! Peripheral memory always starts with 0x4.</p>
</blockquote>
<p>It's time to explore what the <code>Led</code> API does under the hood.</p>
<p>In a nutshell, it just writes to some special memory regions. Go into the
<code>06-registers</code> directory and let's run the starter code.</p>
<pre><code class="language-rust">#![no_std]
#![no_main]

extern crate pg;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    unsafe {
        // A magic address!
        const GPIOE_BSRR: u32 = 0x4800_1018;

        // Turn on the North LED (red)
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

        // Turn on the East LED (green)
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

        // Turn off the North LED
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);

        // Turn on the East LED
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
    }

    loop {}
}
</code></pre>
<p>What's this magic?</p>
<p>The address <code>0x4800_1018</code> points to a <em>register</em>. A register is special region
of memory that controls a <em>peripheral</em>. A peripheral is a piece of electronics
that sits right next to the processor within the microcontroller package and
provides the processor extra functionality. After all, the processor, on its
own, can only do math and logic.</p>
<p>This particular register controls General Purpose Input/Output (GPIO) <em>pins</em>
(GPIO <em>is</em> a peripheral) and can be used to <em>drive</em> each of those pins <em>low</em> or
<em>high</em>.</p>
<h2>An aside: LEDs, digital outputs and voltage levels</h2>
<p>Drive? Pin? Low? High?</p>
<p>A pin is a electrical contact. Our microcontroller has several of them and some
of them are connected to LEDs. An LED, a Light Emitting Diode, will only emit
light when voltage is applied to it with a certain polarity.</p>
<p align="center">
<img height=180 title="LED circuit" src="https://upload.wikimedia.org/wikipedia/commons/c/c9/LED_circuit.svg">
</p>
<p>Luckily for us, the microcontroller's pins are connected to the LEDs with the
right polarity. All that we have to do is <em>output</em> some non-zero voltage through
the pin to turn the LED on. The pins attached to the LEDs are configured as
<em>digital outputs</em> and can only output two different voltage levels: &quot;low&quot;, 0
Volts, or &quot;high&quot;, 3 Volts. A &quot;high&quot; (voltage) level will turn the LED on whereas
a &quot;low&quot; (voltage) level will turn it off.</p>
<p>These &quot;low&quot; and &quot;high&quot; states map directly to the concept of digital logic.
&quot;low&quot; is <code>0</code> or <code>false</code> and &quot;high&quot; is <code>1</code> or <code>true</code>. This is why this pin
configuration is known as digital output.</p>
<hr />
<p>OK. But how can one find out what this register does? Time to RTRM!</p>
<h1>RTRM: Reading The Reference Manual</h1>
<p>I mentioned that the microcontroller has several pins. For convenience, these
pins are grouped in &quot;ports&quot; of 16 pins. Each port is named with a letter: Port
A, Port B, etc. and the pins within each port are named with numbers from 0
to 15.</p>
<p>The first thing we have to find out is which pin is connected to which LED. This
information is in the STM32F3DISCOVERY <a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">User Manual</a> (You downloaded a copy,
right?). In this particular section:</p>
<blockquote>
<p>Section 6.4 LEDs - Page 18</p>
</blockquote>
<p>The manual says:</p>
<ul>
<li><code>LD3</code>, the North LED, is connected to the pin <code>PE9</code>. <code>PE9</code> is the short form
of: Pin 9 on Port E.</li>
<li><code>LD7</code>, the East LED, is connected to the pin <code>PE11</code>.</li>
</ul>
<p>Up to this point, we know that we want to change the state of the pins PE9 and
PE11 to turn the North/East LEDs on/off. These pins are part of Port E so we'll
have to deal with the <code>GPIOE</code> peripheral.</p>
<p>Each peripheral has a register &quot;block&quot; associated to it. A register block is a
collection of registers allocated in contiguous memory. The address at which
the register block starts is known as its base address. We need to figure out
what's the base address of the <code>GPIOE</code> peripheral. That information is in the
following section of the microcontroller Reference Manual:</p>
<blockquote>
<p>Section 3.2.2 Memory map and register boundary addresses - Page 51</p>
</blockquote>
<p>The table says that base address of the <code>GPIOE</code> register block is <code>0x4800_1000</code>.</p>
<p>Each peripheral also has its own section in the documentation. Each of these
sections ends with a table of the registers that the peripheral's register block
contains. For the <code>GPIO</code> family of peripheral, that table is in:</p>
<blockquote>
<p>Section 11.4.12 GPIO register map - Page 243</p>
</blockquote>
<p>We are interested in the register that's at an offset of <code>0x18</code> from the base
address of the <code>GPIOE</code> peripheral. According to the table, that would be the
register <code>BSRR</code>.</p>
<p>Now we need to jump to the documentation of that particular register. It's a few
pages above in:</p>
<blockquote>
<p>Section 11.4.7 GPIO port bit set/reset register (GPIOx_BSRR) - Page 240</p>
</blockquote>
<p>Finally!</p>
<p>This is the register we were writing to. The documentation says some interesting
things. First, this register is write only ... so let's try reading its value
<code>:-)</code>.</p>
<p>We'll use GDB's &quot;examine&quot; command: <code>x</code>.</p>
<pre><code>(gdb) next
14              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

(gdb) x 0x48001018
0x48001018:     0x00000000

(gdb) next
17              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

(gdb) x 0x48001018
0x48001018:     0x00000000
</code></pre>
<p>Reading the register returns <code>0</code>. That matches what the documentation says.</p>
<p>The other thing that the documentation says is that the bits 0 to 15 can be used
to &quot;set&quot; the corresponding pin. That is bit 0 &quot;sets&quot; the pin 0. Here, &quot;set&quot;
means outputting a &quot;high&quot; value on the pin.</p>
<p>The documentation also says that bits 16 to 31 can be used to &quot;reset&quot; the
corresponding pin. In this case, the bit 16 resets the pin number 0. As you may
guess, &quot;reset&quot; means outputting a &quot;low&quot; value on the pin.</p>
<p>Correlating that information with our program, all seems to be in agreement:</p>
<ul>
<li>
<p>Writing <code>1 &lt;&lt; 9</code> (<code>BS9 = 1</code>)  to <code>BSRR</code>  sets <code>PE9</code> <em>high</em>. That turns the
North LED <em>on</em>.</p>
</li>
<li>
<p>Writing <code>1 &lt;&lt; 11</code> (<code>BS11 = 1</code>) to <code>BSRR</code> sets <code>PE11</code> <em>high</em>. That turns the
East LED <em>on</em>.</p>
</li>
<li>
<p>Writing <code>1 &lt;&lt; 25</code> (<code>BR9 = 1</code>) to <code>BSRR</code> sets <code>PE9</code> <em>low</em>. That turns the
North LED <em>off</em>.</p>
</li>
<li>
<p>Finally, writing <code>1 &lt;&lt; 27</code> (<code>BR11 = 1</code>) to <code>BSRR</code> sets <code>PE11</code> <em>low</em>. That
turns the East LED <em>off</em>.</p>
</li>
</ul>
<h1>(mis)Optimization</h1>
<p>Reads/writes to registers are quite special. I may even dare to say that they
are embodiment of side effects. In the previous example we wrote four different
values to the same register. If you didn't know that address was a register, you
may have simplified the logic to just write the final value <code>1 &lt;&lt; (11 + 16)</code>
into the register.</p>
<p>Actually, LLVM does not know this is a register and will merge the writes thus
changing the behavior of our program. Let's check that really quick.</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf --release

$ arm-none-eabi-gdb target/thumbv7em-none-eabihf/release/registers

(gdb) disassemble /m
Dump of assembler code for function main:
   0x080001da &lt;+0&gt;:     movw    r0, #4120       ; 0x1018
   0x080001de &lt;+4&gt;:     mov.w   r1, #134217728  ; 0x8000000
=&gt; 0x080001e2 &lt;+8&gt;:     movt    r0, #18432      ; 0x4800
   0x080001e6 &lt;+12&gt;:    str     r1, [r0, #0]
   0x080001e8 &lt;+14&gt;:    b.n     0x80001e8 &lt;main+14&gt;
End of assembler dump.

(gdb) stepi
0x080001e6 in main ()

(gdb) stepi
0x080001e8 in main ()
</code></pre>
<p>The state of the LEDs didn't change this time! The <code>str</code> instruction is the one
that writes a value to the register. Our &quot;debug&quot; program had four of them, one
for each write to the register, but the &quot;release&quot; program only has one.</p>
<p>We can check that using <code>objdump</code>:</p>
<pre><code>$ arm-none-eabi-objdump -Cd target/thumbv7em-none-eabihf/debug/registers
0800021c &lt;main&gt;:
 800021c:       b082            sub     sp, #8
 800021e:       e7ff            b.n     8000220 &lt;main+0x4&gt;
 8000220:       e7ff            b.n     8000222 &lt;main+0x6&gt;
 8000222:       f241 0018       movw    r0, #4120       ; 0x1018
 8000226:       f6c4 0000       movt    r0, #18432      ; 0x4800
 800022a:       f44f 7100       mov.w   r1, #512        ; 0x200
 800022e:       6001            str     r1, [r0, #0] &lt;--
 8000230:       e7ff            b.n     8000232 &lt;main+0x16&gt;
 8000232:       f241 0018       movw    r0, #4120       ; 0x1018
 8000236:       f6c4 0000       movt    r0, #18432      ; 0x4800
 800023a:       f44f 6100       mov.w   r1, #2048       ; 0x800
 800023e:       6001            str     r1, [r0, #0] &lt;--
 8000240:       e7ff            b.n     8000242 &lt;main+0x26&gt;
 8000242:       e7ff            b.n     8000244 &lt;main+0x28&gt;
 8000244:       f241 0018       movw    r0, #4120       ; 0x1018
 8000248:       f6c4 0000       movt    r0, #18432      ; 0x4800
 800024c:       f04f 7100       mov.w   r1, #33554432   ; 0x2000000
 8000250:       6001            str     r1, [r0, #0] &lt;--
 8000252:       e7ff            b.n     8000254 &lt;main+0x38&gt;
 8000254:       e7ff            b.n     8000256 &lt;main+0x3a&gt;
 8000256:       f241 0018       movw    r0, #4120       ; 0x1018
 800025a:       f6c4 0000       movt    r0, #18432      ; 0x4800
 800025e:       f04f 6100       mov.w   r1, #134217728  ; 0x8000000
 8000262:       6001            str     r1, [r0, #0] &lt;--
 8000264:       e7ff            b.n     8000266 &lt;main+0x4a&gt;
 8000266:       e7fe            b.n     8000266 &lt;main+0x4a&gt;
</code></pre>
<p>How do we prevent LLVM from misoptimizing our program? We use <em>volatile</em>
operations instead of plain reads/writes:</p>
<pre><code class="language-rust">pub extern &quot;C&quot; fn main() -&gt; ! {
    use core::ptr;

    unsafe {
        // A magic address!
        const GPIOE_BSRR: u32 = 0x48001018;

        // Turn on the &quot;North&quot; LED (red)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        // Turn on the &quot;East&quot; LED (green)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        // Turn off the &quot;North&quot; LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        // Turn on the &quot;East&quot; LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}
</code></pre>
<p>If we look at the disassemble of this new program compiled in release mode:</p>
<pre><code>$ arm-none-eabi-objdump -Cd target/thumbv7em-none-eabihf/release/registers

080001da &lt;main&gt;:
 80001da:       f241 0018       movw    r0, #4120       ; 0x1018
 80001de:       f44f 7100       mov.w   r1, #512        ; 0x200
 80001e2:       f6c4 0000       movt    r0, #18432      ; 0x4800
 80001e6:       6001            str     r1, [r0, #0] &lt;--
 80001e8:       f44f 6100       mov.w   r1, #2048       ; 0x800
 80001ec:       6001            str     r1, [r0, #0] &lt;--
 80001ee:       f04f 7100       mov.w   r1, #33554432   ; 0x2000000
 80001f2:       6001            str     r1, [r0, #0] &lt;--
 80001f4:       f04f 6100       mov.w   r1, #134217728  ; 0x8000000
 80001f8:       6001            str     r1, [r0, #0] &lt;--
 80001fa:       e7fe            b.n     80001fa &lt;main+0x20&gt;
</code></pre>
<p>We see that the four writes (<code>str</code> instructions) are preserved. If you run it,
you'll also see that behavior of the program is preserved.</p>
<h1><code>0xBAAAAAAD</code> address</h1>
<p>Not all the peripheral memory can be accessed. Look at this program.</p>
<pre><code class="language-rust">pub extern &quot;C&quot; fn main() -&gt; ! {
    unsafe {
        ptr::read_volatile(0x4800_1800 as *const u32);
    }

    loop {}
}
</code></pre>
<p>This address is close to the <code>GPIOE_BSRR</code> address we used before but this
address is &quot;invalid&quot;. Invalid in the sense that there's no register at this
address.</p>
<p>Now, let's try it. Make sure you have <code>itmdump</code> running.</p>
<p>After executing the <code>read_volatile</code> statement, you should see this in
<code>itmdump</code>'s console:</p>
<pre><code># itmdump's console
EXCEPTION HardFault @ PC=0x0800022a
</code></pre>
<p>We tried to do an invalid operation, reading memory that doesn't exist, so the
processor raised an <em>exception</em>, a <em>hardware</em> exception.</p>
<p>In most cases, exceptions are raised when the processor attempts to perform an
invalid operation. Exceptions break the normal flow of a program and force the
processor to execute an <em>exception handler</em>, which is just a
function/subroutine.</p>
<p>There are different kind of exceptions. Each kind of exception is raised by
different conditions and each one is handled by a different exception handler.</p>
<p>The <code>pg</code> crate provides a catch-all exception handler and that's what the
processor executed upon encountering the &quot;invalid memory address&quot; exception.
That handler is also what caused the <code>EXCEPTION</code> line to be printed to the ITM.</p>
<p>This <code>EXCEPTION</code> line provides information about the exception. It tells us its
kind: <code>HardFault</code> and which instruction caused the exception: the one at address
<code>0x0800022a</code>.</p>
<p>The exception handler also triggered a breakpoint (via <code>bkpt!()</code>) so the
debugger should have halted your program while it was executing the exception
handler.</p>
<p>Let's disassemble the program around the bad instruction.</p>
<pre><code>(gdb) disassemble /m 0x0800022a
Dump of assembler code for function core::ptr::read_volatile&lt;u32&gt;:
213     pub unsafe fn read_volatile&lt;T&gt;(src: *const T) -&gt; T {
   0x0800021c &lt;+0&gt;:     sub     sp, #20
   0x0800021e &lt;+2&gt;:     mov     r1, r0
   0x08000220 &lt;+4&gt;:     str     r0, [sp, #16]
   0x08000222 &lt;+6&gt;:     str     r1, [sp, #4]
   0x08000224 &lt;+8&gt;:     b.n     0x8000226 &lt;core::ptr::read_volatile&lt;u32&gt;+10&gt;
   0x08000226 &lt;+10&gt;:    ldr     r0, [sp, #16]
   0x08000228 &lt;+12&gt;:    str     r0, [sp, #12]
   0x0800022a &lt;+14&gt;:    ldr     r0, [r0, #0] &lt;--
   0x0800022c &lt;+16&gt;:    str     r0, [sp, #8]
   0x08000232 &lt;+22&gt;:    ldr     r0, [sp, #0]
   0x08000234 &lt;+24&gt;:    add     sp, #20
   0x08000236 &lt;+26&gt;:    bx      lr

214         intrinsics::volatile_load(src)
   0x0800022e &lt;+18&gt;:    str     r0, [sp, #0]
   0x08000230 &lt;+20&gt;:    b.n     0x8000232 &lt;core::ptr::read_volatile&lt;u32&gt;+22&gt;
</code></pre>
<p>The exception was caused by a <code>ldr</code> instruction, a read instruction. The
instruction tried to read the memory at the address indicated by the <code>r0</code>
register. BTW, <code>r0</code> is a CPU (processor) register not a microcontroller
register.</p>
<p>Wouldn't it be nice if we could check what was the value of the <code>r0</code> register
right at the instant at which the exception was raised? Well, we can!</p>
<p>If you looked carefully at the GDB output right when the exception was hit, you
probably saw this:</p>
<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.
f3::exception::default_handler (sf=0x20009fa0) at $F3/src/exception.rs:82
</code></pre>
<p>The exception handler we are in right now was called with an argument. Let's
inspect that argument:</p>
<pre><code>(gdb) p sf
$5 = (cortex_m::StackFrame *) 0x20009fa8

(gdb) p/x *sf
$4 = cortex_m::StackFrame {
  r0: 0x48001800,
  r1: 0x48001800,
  r2: 0xd,
  r3: 0x40013800,
  r12: 0x2,
  lr: 0x8000217,
  pc: 0x80001f4,
  xpsr: 0x41000200
}
</code></pre>
<p>This <code>StackFrame</code> struct contains the state of your program right before the
exception was hit. There's an <code>r0</code> field in it. That's the value of <code>r0</code> right
before the exception was raised. It contains the value <code>0x4800_1800</code> which is
the invalid address we fed to the <code>read_volatile</code> function.</p>
<h1>Spooky action at a distance</h1>
<p><code>BSRR</code> is not the only register that can control the pins of Port E. The <code>ODR</code>
register also lets you change the value of the pins. Furthermore, <code>ODR</code> also
lets you retrieve the current output status of Port E.</p>
<p><code>ODR</code> is documented in:</p>
<blockquote>
<p>Section 11.4.6 GPIO port output data register - Page 239</p>
</blockquote>
<p>Let's try this program:</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    unsafe {
        const GPIOE_BSRR: u32 = 0x4800_1018;
        const GPIOE_ODR: u32 = 0x4800_1014;

        iprintln!(&quot;ODR = 0x{:04x}&quot;,
                  ptr::read_volatile(GPIOE_ODR as *const u16));

        // Turn on the NORTH LED (red)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        iprintln!(&quot;ODR = 0x{:04x}&quot;,
                  ptr::read_volatile(GPIOE_ODR as *const u16));

        // Turn on the EAST LED (green)
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        iprintln!(&quot;ODR = 0x{:04x}&quot;,
                  ptr::read_volatile(GPIOE_ODR as *const u16));

        // Turn off the NORTH LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        iprintln!(&quot;ODR = 0x{:04x}&quot;,
                  ptr::read_volatile(GPIOE_ODR as *const u16));

        // Turn off the EAST LED
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}

</code></pre>
<p>If you run this program, you'll see:</p>
<pre><code># itmdump's console
ODR = 0x0000
ODR = 0x0200
ODR = 0x0a00
ODR = 0x0800
</code></pre>
<p>Side effects! Although we are reading the same address multiple times without
actually modifying it, we still see its value change every time <code>BSRR</code> is
written to.</p>
<h1>Type safe manipulation</h1>
<p>The last register we were working with, <code>ODR</code>, had this in its documentation:</p>
<blockquote>
<p>Bits 16:31 Reserved, must be kept at reset value</p>
</blockquote>
<p>We are not supposed to write to those bits of the register or Bad Stuff May
Happen.</p>
<p>There's also the fact the registers have different read/write permissions. Some
of them are write only, others can be read and wrote to and there must be others
that are read only.</p>
<p>Finally, directly working with hexadecimal addresses is error prone. You already
saw that trying to access an invalid memory address causes an exception which
disrupts the execution of our program.</p>
<p>Wouldn't it be nice if we had an API to manipulate registers in a &quot;safe&quot; manner?
Ideally, the API should encode these three points I've mentioned: No messing
around with the actual addresses, should respect read/write permissions and
should prevent modification of the reserved parts of a register.</p>
<p>Well, we do! The <code>pg</code> crate contains a <code>peripheral</code> module that provides such
API.</p>
<p>Each register block is modeled as a <code>struct</code> where each field is a register.
Each register is a different newtype over e.g. <code>u32</code> and exposes a combination
of the following methods: <code>read</code>, <code>write</code> or <code>modify</code> according to its
read/write permissions. Finally, these methods don't take primitive values like
<code>u32</code>, instead they take yet another newtype that can be constructed using the
builder pattern and that prevent the modification of the reserved parts of a
register.</p>
<p>The best way to get familiar with this API is to port our running example to it.</p>
<pre><code class="language-rust">#![no_std]
#![no_main]

extern crate pg;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    use pg::peripheral;

    // Get mutable access to the GPIOE register block
    // `unsafe` because this functions hands over (aliases) `&amp;mut-` references
    let gpioe = unsafe { peripheral::gpioe_mut() };

    // Turn on the North LED
    gpioe.bsrr.write(|w| w.bs9(true));

    // Turn on the East LED
    gpioe.bsrr.write(|w| w.bs11(true));

    // Turn off the North LED
    gpioe.bsrr.write(|w| w.br9(true));

    // Turn off the East LED
    gpioe.bsrr.write(|w| w.br11(true));

    loop {}
}
</code></pre>
<p>First thing you notice: There are no magic addresses involved. Instead we use a
more human friendly: <code>gpioe.bsrr</code> to refer to the <code>BSRR</code> register in the <code>GPIOE</code>
register block.</p>
<p>Then we have this <code>write</code> method that takes a closure. If the &quot;identity&quot; closure
is used: <code>|w| w</code>, this method will set the register to its &quot;reset value&quot;, the
value it had right after the microcontroller was powered on / reset. That value
is <code>0x0</code> for the <code>BSRR</code> register. Since we want to write a non-zero value to the
register, we use builder methods like <code>bs9</code> to set (<code>true</code>) or reset (<code>false</code>)
some of the bits of the register value.</p>
<p>Let's run this program! There's some interesting stuff we can do <em>while</em>
debugging the program.</p>
<p><code>gpioe</code> is a reference to the <code>GPIOE</code> register block. <code>print gpioe</code> will return
the base address of the register block.</p>
<pre><code>$ (gdb) print gpioe
$1 = (f3::peripheral::gpio::Gpio *) 0x48001000
</code></pre>
<p>But if we instead <code>print *gpioe</code>, we'll get a &quot;full view&quot; of the register block.
The value of each of its registers will be printed. I recommend setting <code>set print pretty on</code> first, though, to make the output more readable.</p>
<pre><code>(gdb) set print pretty on

(gdb) print *gpioe
$2 = f3::peripheral::gpio::Gpio {
  moder: f3::peripheral::gpio::Moder {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x55550000
    }
  },
  otyper: f3::peripheral::gpio::Otyper {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  ospeedr: f3::peripheral::gpio::Ospeedr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  pupdr: f3::peripheral::gpio::Pupdr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  idr: f3::peripheral::gpio::Idr {
    register: volatile_register::RO&lt;u32&gt; {
      register: 0xcc
    }
  },
  odr: f3::peripheral::gpio::Odr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  bsrr: f3::peripheral::gpio::Bsrr {
    register: volatile_register::WO&lt;u32&gt; {
      register: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: f3::peripheral::gpio::Lckr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  afrl: f3::peripheral::gpio::Afrl {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  afrh: f3::peripheral::gpio::Afrh {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  brr: f3::peripheral::gpio::Brr {
    register: volatile_register::WO&lt;u32&gt; {
      register: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<p>All these newtypes and closures sound like they'd generate large, bloated
programs but, if you actually compile the program in release mode with LTO
enabled, you'll see that it produces exactly the same instructions that the
&quot;unsafe&quot; version that used <code>write_volatile</code> and hexadecimal addresses did!</p>
<pre><code>$ arm-none-eabi-objdump -Cd target/thumbv7em-none-eabihf/release/registers

080001da &lt;main&gt;:
 80001da:       f241 0018       movw    r0, #4120       ; 0x1018
 80001de:       f44f 7100       mov.w   r1, #512        ; 0x200
 80001e2:       f6c4 0000       movt    r0, #18432      ; 0x4800
 80001e6:       6001            str     r1, [r0, #0]
 80001e8:       f44f 6100       mov.w   r1, #2048       ; 0x800
 80001ec:       6001            str     r1, [r0, #0]
 80001ee:       f04f 7100       mov.w   r1, #33554432   ; 0x2000000
 80001f2:       6001            str     r1, [r0, #0]
 80001f4:       f04f 6100       mov.w   r1, #134217728  ; 0x8000000
 80001f8:       6001            str     r1, [r0, #0]
 80001fa:       e7fe            b.n     80001fa &lt;main+0x20&gt;
</code></pre>
<p>The best part of all this is that I didn't have to write a single line of code
in the <code>peripheral</code> module. All was automatically generated from a System View
Description (SVD) file using the <a href="https://crates.io/crates/svd2rust">svd2rust</a> tool. This SVD file is actually an
XML file that microcontroller vendors provide and that contains the register
maps of their microcontrollers. The file contains the layout of register blocks,
its base addresses, the read/write permissions of each register, the layout of
the registers, whether a register has reserved bits and much more information.</p>
<h1>LEDs, again</h1>
<p>In the last section, I gave you &quot;initialized&quot; peripherals (I initialized them
before <code>main</code>). That's why just writing to <code>BSRR</code> was enough to control the
LEDs. But, peripheral are not &quot;initialized&quot; right after the microcontroller
boots.</p>
<p>In this section, you'll have more &quot;fun&quot; with registers: You'll have to configure
<code>GPIOE</code> pins as digital outputs so that you'll be able to drive LEDs again.</p>
<p>This is the starter code.</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let (gpioe, rcc) =
        unsafe { (peripheral::gpioe_mut(), peripheral::rcc_mut()) };

    // TODO initialize GPIOE

    // Turn on all the LEDs in the compass
    gpioe.odr.write(|w| {
        w.odr8(true)
            .odr9(true)
            .odr10(true)
            .odr11(true)
            .odr12(true)
            .odr13(true)
            .odr14(true)
            .odr15(true)
    });

    loop {}
}
</code></pre>
<p>If you run the starter code, you'll see that nothing happens this time.
Furthermore, if you print the <code>GPIOE</code> register block, you'll see that every
register is &quot;zeroed&quot; even after the <code>gpioe.odr.write</code> statement was executed!</p>
<pre><code>(gdb) p/x *gpioe
$1 = f3::peripheral::gpio::Gpio {
  moder: f3::peripheral::gpio::Moder {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  otyper: f3::peripheral::gpio::Otyper {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  ospeedr: f3::peripheral::gpio::Ospeedr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  pupdr: f3::peripheral::gpio::Pupdr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  idr: f3::peripheral::gpio::Idr {
    register: volatile_register::RO&lt;u32&gt; {
      register: 0x0
    }
  },
  odr: f3::peripheral::gpio::Odr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  bsrr: f3::peripheral::gpio::Bsrr {
    register: volatile_register::WO&lt;u32&gt; {
      register: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: f3::peripheral::gpio::Lckr {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  afrl: f3::peripheral::gpio::Afrl {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  afrh: f3::peripheral::gpio::Afrh {
    register: volatile_register::RW&lt;u32&gt; {
      register: 0x0
    }
  },
  brr: f3::peripheral::gpio::Brr {
    register: volatile_register::WO&lt;u32&gt; {
      register: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<h1>Power</h1>
<p>Turns out that, to save power, most peripherals start, that is right after boot,
in a powered off state.</p>
<p>The Reset and Clock Control (<code>RCC</code>) peripheral can be used to power on or off
every other peripheral.</p>
<p>You can find the list of registers in the <code>RCC</code> register block in:</p>
<blockquote>
<p>Section 9.4.14 - RCC register map - Page 166 - Reference Manual</p>
</blockquote>
<p>The registers that control the power status of other peripherals are:</p>
<ul>
<li><code>AHBENR</code></li>
<li><code>APB1ENR</code></li>
<li><code>APB2ENR</code></li>
</ul>
<p>Each bit in these registers controls the power status of a single peripheral,
including <code>GPIOE</code>.</p>
<p>Your task is this section is to power on the <code>GPIOE</code> peripheral. You'll have to:</p>
<ul>
<li>Figure out which of the three registers I mentioned before has the bit that
controls the power status.</li>
<li>Figure out what value that bit must be set to,<code>0</code> or <code>1</code>, to power on the
<code>GPIOE</code> peripheral.</li>
<li>Finally, you'll have to change the starter code to <em>modify</em> the right
register to turn on the <code>GPIOE</code> peripheral.</li>
</ul>
<p>If you are successful, you'll see that the <code>gpioe.odr.write</code> statement will now
be able to modify the value of the <code>ODR</code> register.</p>
<p>Note that this won't be enough to actually turn on the LEDs.</p>
<h1>Configuration</h1>
<p>After turning on the GPIOE peripheral. The peripheral still needs to be
configured. In this case, we want the pins to be configured as digital
<em>outputs</em> so they can drive the LEDs; by default, all/most pins are configured
as digital <em>inputs</em>.</p>
<p>You can find the list of registers in the <code>GPIOE</code> register block in:</p>
<blockquote>
<p>Section 11.4.12 - GPIO registers - Page 243 - Reference Manual</p>
</blockquote>
<p>The register we'll have to deal with is: <code>MODER</code>.</p>
<p>Your task for this section is to further update the starter code to configure
the <em>right</em> <code>GPIOE</code> pins as digital outputs. You'll have to:</p>
<ul>
<li>Figure out <em>which</em> pins you need to configure as digital outupts. (hint: check
Section 6.4 LEDs of the <em>User Manual</em> (page 18)).</li>
<li>Read the documentation to understand what the bits in the <code>MODER</code> registry do.</li>
<li>Modify the <code>MODER</code> registry to configure the pins as digital outputs.</li>
</ul>
<p>If successful, you'll see the 8 LEDs turn on when you run the program.</p>
<h1>Clocks and timers</h1>
<p>Summary:</p>
<ul>
<li>Same routine: power up, configure</li>
<li>As before, I'll point you to the documentation</li>
<li>APB1 Clock: 8 MHz</li>
<li>Configuration: one shot, autoreload, prescaler</li>
<li>Introduce: busy waiting <code>while !tim7.sr.read().uif() {}</code></li>
<li>Re-implement <code>delay::ms</code></li>
</ul>
<hr />
<p>In this section, we'll re-implement the LED roulette application. I'm going to
give you back the <code>led</code> module but this time I'm going to take away the <code>delay</code>
module <code>:-)</code>.</p>
<p>Here's the starter code. The <code>delay</code> function is unimplemented so if you run
this program the LEDs will blink so fast that they'll appear to always be on.</p>
<pre><code class="language-rust">#![no_std]
#![no_main]

extern crate pg;

use core::iter;

use pg::led::LEDS;
use pg::peripheral;

#[inline(never)]
fn delay(ms: u16) {
    // TODO implement this
}

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    unsafe {
        let rcc = peripheral::rcc_mut();
        let tim7 = peripheral::tim7_mut();
    }

    // TODO initialize TIM7

    loop {
        for (current, next) in LEDS.iter()
            .zip(LEDS.iter().skip(1).chain(iter::once(&amp;LEDS[0]))) {
            next.on();
            delay(50);
            current.off();
            delay(50);
        }
    }
}
</code></pre>
<hr />
<p>Functional description:</p>
<ul>
<li>The timer is enabled</li>
<li>A counter register increments its value on each &quot;tick&quot;</li>
<li>When the counter reaches the value held in the auto-reload register, it will
reset back to zero and generate an <em>update</em> event.</li>
</ul>
<p>The timer can operate in two modes:</p>
<ul>
<li>Continuous mode: After an update event, the timer will start counting again.</li>
<li>One pulse mode: After an update event, the timer will stop.</li>
</ul>
<p>How long lasts this &quot;tick&quot;? It's determined by the APB1 clock and th</p>
<p>TIM registers - Section 22.4 - Page 681 - Reference Manual</p>
<p>Initialization is as usual: power up the peripheral then configure it.</p>
<ul>
<li>
<p>Use <code>TIM7EN</code> in <code>RCC::APB1ENR</code> to power up the peripheral.</p>
</li>
<li>
<p><code>TIM7::CR1</code> the configuration register.</p>
</li>
<li>
<p><code>TIM7::PSC</code> the prescaler register.</p>
</li>
<li>
<p><code>TIM7::ARR</code> the auto-reload register</p>
</li>
<li>
<p><code>TIM7::CNT</code> the counter register</p>
</li>
<li>
<p><code>TIM7::SR</code> the status register, indicates if an update event has occurred</p>
</li>
<li>
<p><code>TIM7::EGR</code> the event generation register. Can be used to generate an update
event.</p>
</li>
</ul>
<p>The catch: the auto-reload register is buffered. When you write to it, it won't
immediately change until the <em>next</em> update event. You can synthesize an update
event using EGR.</p>
<h1><code>for</code> loop delays</h1>
<p>The first challenge is to implement the <code>delay</code> function without using any
peripheral and the obvious solution is to implement it as a <code>for</code> loop delay:</p>
<pre><code class="language-rust">#[inline(never)]
fn delay(ms: u16) {
    for _ in 0..1_000 {}
}
</code></pre>
<p>Of course, the above implementation is wrong because it always generates the
same delay for any value of <code>ms</code>.</p>
<p>In this section, you'll have to:</p>
<ul>
<li>Fix the <code>delay</code> function to generate delays proportional to its input <code>ms</code>.</li>
<li>Tweak the <code>delay</code> function to make the LED roulette spin at a rate of
approximately 5 cycles in 4 seconds (800 milliseconds period).</li>
<li>The processor inside the microcontroller is clocked at 8 MHz and executes most
instructions in one &quot;tick&quot;, a cycle of its clock. How many (<code>for</code>) loops do
you <em>think</em> the <code>delay</code> function must do to generate a delay of 1 second?</li>
<li>How many <code>for</code> loops does <code>delay(1000)</code> actually do?</li>
<li>What happens if compile your program in &quot;release&quot; mode and run it?</li>
</ul>
<h1>NOP</h1>
<p>If in the previous section you compiled the program in release mode and actually
looked at the disassembly, you probably noticed that the <code>delay</code> function got
optimized away and never got called from within <code>main</code>.</p>
<p>LLVM decided that the function wasn't doing anything worthwhile and just removed
it.</p>
<p>There is a way to prevent LLVM from optimizing the <code>for</code> loop delay: a volatile
assembly instruction. Any instruction will do but NOP (No OPeration) is a
particular good choice in this case because it actually does nothing.</p>
<p>Your <code>for</code> loop delay would become:</p>
<pre><code class="language-rust">#[inline(never)]
fn delay(ms: u16) {
    for _ in 1_000 {
        unsafe { asm!(&quot;nop&quot; :::: &quot;volatile&quot;) }
    }
}
</code></pre>
<p>And this time it won't be compiled away by LLVM when you compile your program in
release mode:</p>
<pre><code>$ arm-none-eabi-objdump -Cd target/thumbv7em-none-eabihf/release/clocks-and-timers

080001da &lt;clocks_and_timers::delay::hc83787721a209f96&gt;:
 80001da:       f44f 707a       mov.w   r0, #1000       ; 0x3e8
 80001de:       3801            subs    r0, #1
 80001e0:       bf00            nop
 80001e2:       d1fc            bne.n   80001de &lt;clocks_and_timers::delay::hc83787721a209f96+0x4&gt;
 80001e4:       4770            bx      lr
</code></pre>
<p>Now, test this: Compile the program in debug mode and run it then compile the
program in release mode and run it. What's the difference between them? What do
you think is the main cause of the difference? Can you think of a way to make
them equivalent or at least more similar again?</p>
<h1>One-shot timer</h1>
<p>I hope that, by now, I have convinced you that <code>for</code> loop delays are a poor way
to implement delays.</p>
<p>Now, we'll implement delays using a &quot;timer&quot;. The basic function of a timer is
... to keep precise track of time. A timer is yet another peripheral that's
available to the microcontroller thus it can be controlled using registers.</p>
<p>The microcontroller we are using has several (in fact, more than 10) timers of
different kinds (basic, general purpose and advanced timers) available to it.
Some timers have more &quot;precision&quot; than others and some can be used for more than
just keeping track of time.</p>
<p>We'll be using one of the &quot;basic&quot; timers: <code>TIM7</code>. This is one of the simplest
timers available in our microcontroller. The documentation for basic timers is
in the following section:</p>
<blockquote>
<p>Section 22 Timers - Page 674 - Reference Manual</p>
</blockquote>
<p>Its registers are documented in:</p>
<blockquote>
<p>Section 22.4.9 TIM6/TIM7 register map - Page 686 - Reference Manual</p>
</blockquote>
<p>The registers we'll be using in this section are:</p>
<ul>
<li><code>SR</code>. The status register</li>
<li><code>EGR</code>. The event generation register</li>
<li><code>CNT</code>. The counter register</li>
<li><code>PSC</code>. The prescaler register</li>
<li><code>ARR</code>. The autoreload register</li>
</ul>
<p>We'll be using the timer as a &quot;one-shot&quot; timer. It will sort of work like an
alarm clock. We'll set the timer to &quot;go off&quot; after some amount of time and then
we'll wait until the timer &quot;goes off&quot;. The documentation refers to this mode of
operation as &quot;one pulse mode&quot;.</p>
<p>Here's a description of how a basic timer works when configured in one pulse
mode:</p>
<ul>
<li>The counter is enabled by the user (<code>CR1.CEN = 1</code>)</li>
<li>The <code>CNT</code> register resets its value to zero and, on each &quot;tick&quot;, its value
gets incremented by one.</li>
<li>Once the <code>CNT</code> register has reached the value of the <code>ARR</code> register, the
counter will be disabled by hardware (<code>CR1.CEN = 0</code>) and an &quot;update&quot; event
will be raised (<code>SR.UIF = 1</code>).</li>
</ul>
<p><code>TIM7</code> is driven by the APB1 clock, whose frequency doesn't have to necessarily
match the processor frequency. That is the APB1 clock could be running faster or
slower. However, the default is that both APB1 and the processor are clocked at
8 MHz.</p>
<p>The &quot;tick&quot; mentioned in the functional description of the one pulse mode is
<em>not</em> the same as one tick of the APB1 clock. The <code>CNT</code> register usually works
at a slower rate because this register actually operates at a frequency of
<code>APB1_CLOCK / (PSC + 1)</code>, where <code>PSC</code> is the value of the prescaler register
(<code>PSC</code>).</p>
<h1>Initialization</h1>
<p>As with every other peripheral, we'll have to initialize this timer before we
can use it. And just as in the previous section, initialization is going to
involve two steps: powering up the timer and then configuring it.</p>
<p>Powering up the timer is easy: We just have to set <code>TIM7EN</code> bit to 1. This bit
is in the <code>APB1ENR</code> register of the <code>RCC</code> register block.</p>
<pre><code class="language-rust">// Power on the TIM7 timer
rcc.apb1enr.modify(|_, w| w.tim7en(true));
</code></pre>
<p>The configuration part is slightly more elaborated.</p>
<p>First, we'll have to configure the timer to operate in one pulse mode.</p>
<pre><code class="language-rust">// OPM Select the one pulse mode
// CEN Keep the counter disabled for now
tim7.cr1.write(|w| w.opm(false).cen(false));
</code></pre>
<p>Then, we'll like to have the <code>CNT</code> counter operate at a frequency of 1 KHz
because our <code>delay</code> function takes a number of milliseconds as arguments and 1
KHz produces a 1 millisecond period.</p>
<pre><code class="language-rust">// Configure the prescaler to have the counter operate at 1 KHz
tim7.psc.write(|w| w.psc(x));
</code></pre>
<p>I'm going to leave it to you to figure out the value of the prescaler, <code>x</code>.
Remember that the frequency of the counter is <code>APB1_CLOCK / (PSC + 1)</code> and that
<code>APB1_CLOCK</code> is 8 MHz.</p>
<h1>Busy waiting</h1>
<p>The timer should now be properly initialized. All that's left is to implement
the <code>delay</code> function using the timer.</p>
<p>First thing we have to do is set the autoreload register (<code>ARR</code>) to make the
timer go off in <code>ms</code> milliseconds. Because the counter operates at 1 KHz, the
autoreload value will be the same as <code>ms</code>.</p>
<pre><code>// Set the timer to go off in `ms` ticks
// 1 tick = 1 ms
tim7.arr.write(|w| w.arr(ms));
</code></pre>
<p>Next, we need to enable the counter. It will immediately start counting.</p>
<pre><code class="language-rust">// CEN: Enable the counter
tim7.cr1.modify(|_, w| w.cen(true));
</code></pre>
<p>Now we need to wait until the counter reaches the value of the autoreload
register, <code>ms</code>, then we'll know that <code>ms</code> milliseconds have passed. That
condition is known as an &quot;update&quot; event and its indicated by the <code>UIF</code> bit of
the status register (<code>SR</code>).</p>
<pre><code>// Wait until the alarm goes off (the &quot;update event&quot; occurs)
while !tim7.sr.read().uif() {}
</code></pre>
<p>This pattern of just waiting until some condition is met, in this case that
<code>UIF</code> becomes <code>1</code>, is known as &quot;busy&quot; waiting and you'll see it a few more times
during this workshop <code>:-)</code>.</p>
<p>Finally, we must clear (set to <code>0</code>) this <code>UIF</code> bit. If we don't, next time we
enter the <code>delay</code> function we'll think the update event has already happened and
skip over the &quot;busy&quot; waiting part.</p>
<pre><code class="language-rust">// Clear the &quot;update&quot; flag
tim7.sr.write(|w| w);
</code></pre>
<p>Now, put this all together and check if it works as expected.</p>
<h1>Putting it all together</h1>
<pre><code class="language-rust">#![no_std]
#![no_main]

extern crate pg;

use core::iter;

use pg::led::LEDS;
use pg::peripheral;

#[inline(never)]
fn delay(ms: u16) {
    let tim7 = unsafe { peripheral::tim7_mut() };

    // Set the timer to go off in `ms` ticks
    // 1 tick = 1 ms
    tim7.arr.write(|w| w.arr(ms));

    // CEN: Enable the counter
    tim7.cr1.modify(|_, w| w.cen(true));

    // Wait until the alarm goes off (the &quot;update event&quot; occurs)
    while !tim7.sr.read().uif() {}

    // Clear the &quot;update&quot; flag
    tim7.sr.write(|w| w);
}

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let (rcc, tim7) =
        unsafe { (peripheral::rcc_mut(), peripheral::tim7_mut()) };

    // Power on the TIM7 timer
    rcc.apb1enr.modify(|_, w| w.tim7en(true));

    // OPM Select the one pulse mode
    // CEN Keep the counter disabled for now
    tim7.cr1.write(|w| w.opm(false).cen(false));

    // Configure the prescaler to have the counter operate at 1 KHz
    // APB1_CLOCK = 8 MHz
    // PSC = 7999
    // 8 MHz / (7999 + 1) = 1 KHz
    // The counter (CNT) will increase on every millisecond
    tim7.psc.write(|w| w.psc(7_999));

    loop {
        for (current, next) in LEDS.iter()
            .zip(LEDS.iter().skip(1).chain(iter::once(&amp;LEDS[0]))) {
            next.on();
            delay(50);
            current.off();
            delay(50);
        }
    }
}
``
</code></pre>
<h1>&quot;Serial&quot; communication</h1>
<p><a href="https://en.wikipedia.org/wiki/File:Serial_port.jpg"></p>
<p align="center">
<img height="240" title="Standard serial port connector DE-9" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Serial_port.jpg/800px-Serial_port.jpg">
</p>
</a>
<p align="center">
<em>This is what we'll be using. I hope your laptop has one!</em>
</p>
<p>Nah, don't worry. This connector, the DE-9, when out of fashion on PCs quite
some time ago; it got replaced by the Universal Serial Bus (USB). We won't be
dealing with the DE-9 connector itself but with the communication protocol that
this cable is/was usually used for.</p>
<p>So what's this &quot;serial&quot; communication? It's an <em>asynchronous</em> communication
protocol where two devices exchange data &quot;serially&quot;, one bit at a time, using
two data lines (plus a common ground). The protocol is asynchronous in the sense
that neither of the data lines carries a clock signal. Instead both parties must
agree on how fast data will be sent along the wire <em>before</em> the communication
occurs. This protocol allows &quot;duplex&quot; communication as data can be sent from
A to B and from B to A simultaneously.</p>
<p>We'll be using this protocol to exchange data between the microcontroller and
your laptop. In contrast with the ITM protocol we have used before, with the
serial communication protocol we can send data from your laptop to the
microcontroller.</p>
<p>The next practical question you probably want to ask is: How fast can send data
through this protocol?</p>
<p>This protocol works with frames. Each frame has one &quot;start&quot; bit, 5 to 9 bits of
payload and 0 to 2 &quot;stop&quot;&quot; bits. The speed of the protocol is known as baud rate
and it's quoted in bits per second (bps). Common baud rates are: 9600, 19200,
38400, 57600 and 115200 bps.</p>
<p>To actually answer the question: With a common configuration of 1 start bit, 8
bits of payload, zero stop bits and a baud rate of 115200 bps one can, in
theory, send 12,800 frames of 9 bits per second. Since each one carries a byte
of information that results in a data rate of 12.8 KB/s. In practice, the data
rate will be lower because of processing times on the slower side of the
communication (the microcontroller).</p>
<p>Today's laptops/PCs don't support the serial communication protocol. So we can't
directly connect your laptop to the microcontroller. But that's where the serial
module comes in. This module will sit between the two and expose a &quot;serial&quot;
interface to the microcontroller and an USB interface to your laptop. The
microcontroller will see your laptop as another &quot;serial&quot; device and your laptop
will see the microcontroller as a virtual serial device.</p>
<p>Now, let's get familiar with the serial module and the serial communication
tools that your OS offers. Pick a route:</p>
<ul>
<li><a href="09-serial-communication/nix-tooling.html">*nix</a></li>
<li><a href="09-serial-communication/windows-tooling.html">Windows</a></li>
</ul>
<h1>*nix tooling</h1>
<p>Connect the serial module to your laptop and let's find out what name the OS
assigned to it.</p>
<pre><code>$ dmesg | grep -i tty
(..)
[  +0.000155] usb 3-2: FTDI USB Serial Device converter now attached to ttyUSB0
</code></pre>
<blockquote>
<p><strong>NOTE</strong> On macs, the USB device will named like this: <code>cu.usbserial-*</code>.
Adjust the following commands accordingly!</p>
</blockquote>
<p>But what's this <code>ttyUSB0</code> thing? It's a file of course! Everything is a file in
*nix:</p>
<pre><code>$ ls -l /dev/ttyUSB0
crw-rw---- 1 root uucp 188, 0 Oct 27 00:00 /dev/ttyUSB0
</code></pre>
<p>You can send out data by simply writing to this file:</p>
<pre><code>$ echo 'Hello, world!' &gt; /dev/ttyUSB0
</code></pre>
<p>You should see the TX (red) LED on the serial module blink, just once and very
fast!</p>
<h2>minicom</h2>
<p>Dealing with serial devices using <code>echo</code> is far from ergonomic. So, we'll use
the program <code>minicom</code> to interact with the serial device using the keyboard.</p>
<p>We must configure <code>minicom</code> before we use it. There are quite a few ways to do
that but we'll use a <code>.minirc.dfl</code> file in the home directory. Create a file
in <code>~/.minirc.dfl</code> with the following contents:</p>
<pre><code>pu bits 8
pu parity N
pu stopbits 1
pu rtscts No
pu xonxoff No
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Make sure this file ends in a newline! Otherwise, <code>minicom</code> will fail
to read it.</p>
</blockquote>
<p>That file should be straightforward to read (except for the last two lines), but
nonetheless let's go over it line by line:</p>
<ul>
<li><code>pu baudrate 115200</code>. Sets baud rate to 115200.</li>
<li><code>pu bits 8</code>. 8 bits per frame.</li>
<li><code>pu parity N</code>. No parity check.</li>
<li><code>pu stopbits 1</code>. 1 stop bit.</li>
<li><code>pu rtscts No</code>. No hardware control flow.</li>
<li><code>pu xonxoff No</code>. No software control flow.</li>
</ul>
<p>Once that's in place. We can launch <code>minicom</code></p>
<pre><code>$ minicom -D /dev/ttyUSB0 -b 115200
</code></pre>
<p>This tells <code>minicom</code> to &quot;open&quot; the serial device at <code>/dev/ttyUSB0</code> and set its
baud rate to 115200. A text-based user interface (TUI) will pop out.</p>
<p align="center">
<img height="480" title="minicom" src="assets/minicom.png">
</p>
<p>You can now send data using the keyboard! Go ahead and type something. Note that
the TUI <em>won't</em> echo back what you type but you'll see TX (red) LED on the
serial module blink with each keystroke.</p>
<h2><code>minicom</code> commands</h2>
<p><code>minicom</code> exposes commands via keyboard shortcuts. On Linux, the shortcuts start
with <code>Ctrl+A</code>. On mac, the shortcuts start with the <code>Meta</code> key. Some useful
commands below:</p>
<ul>
<li><code>Ctrl+A</code> + <code>Z</code>. Minicom Command Summary</li>
<li><code>Ctrl+A</code> + <code>C</code>. Clear the screen</li>
<li><code>Ctrl+A</code> + <code>X</code>. Exit and reset</li>
<li><code>Ctrl+A</code> + <code>Q</code>. Quit with no reset</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> mac users: In the above commands, replace <code>Ctrl+A</code> with <code>Meta</code>.</p>
</blockquote>
<h1>Windows tooling</h1>
<p>Before plugging the Serial module, run the following command on the terminal:</p>
<pre><code>$ mode
</code></pre>
<p>It will print a list of devices that are connected to your laptop. The ones that
start with <code>COM</code> in their names are serial devices. This is the kind of device
we'll be working with. Take note of all the <code>COM</code> devices <code>mode</code> outputs
<em>before</em> plugging the serial module.</p>
<p>Now, plug the Serial module and run the <code>mode</code> command again. You should see a
new <code>COM</code> command appear on the list. That's the COM port assigned to the serial
module.</p>
<p>Now launch <code>putty</code>. A GUI will pop out.</p>
<p align="center">
<img title="PuTTY settings" src="assets/putty-settings.png">
</p>
<p>On the default screen, &quot;Session&quot;, pick &quot;Serial&quot; as the &quot;Connection type&quot;. On the
&quot;Serial line&quot; field enter the <code>COM</code> device you got on the previous step, for
example <code>COM3</code>.</p>
<p>Next, pick the &quot;Connection/Serial&quot; menu item from the menu on the left. On this
new view, make sure that the serial port is configured as follows:</p>
<ul>
<li>&quot;Speed (baud)&quot;: 115200</li>
<li>&quot;Data bits&quot;: 8</li>
<li>&quot;Stop bits&quot;: 1</li>
<li>&quot;Parity&quot;: None</li>
<li>&quot;Flow control&quot;: None</li>
</ul>
<p>Finally, click the Open button. A console will show up now:</p>
<p align="center">
<img title="PuTTY console" src="assets/putty-console.png">
</p>
<p>If you type on this console, the TX (red) LED on the Serial module should blink.
Each key stroke should make the LED blink once. Note that the console won't echo
back what you type so the screen will remain blank.</p>
<h1>Loopbacks</h1>
<p>We've tested sending data. It's time to test receiving it. Except that there's
no other device that can send us some data ... or is there?</p>
<p>Enter: loopbacks</p>
<p align="center">
<img title="Serial module loopback" src="assets/serial-loopback.png">
</p>
<p>You can send data to yourself! Not very useful in production but very useful for
debugging.</p>
<p>Connect the <code>TXO</code> and the <code>RXI</code> pins of the serial module together using a Male
/ Male jumper wire as shown above.</p>
<p>Now enter some text into minicom/PuTTY and observe. What happens?</p>
<p>You should see three things:</p>
<ul>
<li>As before, the TX (red) LED blinks on each key press.</li>
<li>But now the RX (green) LED blinks on each key press as well! This indicates
that the serial module is receiving some data; the one it just sent.</li>
<li>Finally, on the minicom/PuTTY console, you should see that what you type
echoes back to the console.</li>
</ul>
<p>Now that you are familiar with sending and receiving data over &quot;serial port&quot;
using minicom/PuTTY, let's make your microcontroller and your laptop talk!</p>
<h1>USART</h1>
<p>The microcontroller has a peripheral called USART, which stands for Universal
Synchronous/Asynchronous Receiver/Transmitter. This peripheral can be used to
implement several communication protocols like the &quot;serial&quot; communication
protocol.</p>
<p>Throughout this chapter, we'll use &quot;serial&quot; communication to exchange
information between the microcontroller and your laptop. But before we do that
we have to wire up everything.</p>
<p>I mentioned before that this protocol involves two data lines: TX and RX. TX
stands for transmitter and RX stands for receiver. Which is which depends from
which device we are looking the lines at.</p>
<p>We'll be using the pin <code>PA9</code> as the TX line and <code>PA10</code> as the RX line. IOW, the
pin <code>PA9</code> outputs data onto its wire wheres the pin <code>PA10</code> listens for data on
its wire.</p>
<p>We could have used a different pair of pins as the TX and RX pins. There's a
table in page 44 of the <a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">Data Sheet</a> that list all the other possible pins we
could have used.</p>
<p>The serial module also has TX and RX pins. We'll have to &quot;cross&quot; these pins that
is connect the microcontroller's TX pin to the serial module's RX pin and the
micro's RX pin to the serial module's TX pin. The wiring diagram below shows all
the necessary connections.</p>
<p align="center">
<img height=640 title="F3 <-> Serial connection" src="assets/f3-serial.png">
</p>
<p>These are the recommended steps to connect the microcontroller and the serial
module:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code></li>
<li>Disconnect the USB cables from the F3 and the serial module.</li>
<li>Connect one of F3 GND pins to the GND pin of the serial module using a Female
/ Male (F/M) wire. Preferably, a black one.</li>
<li>Connect the PA9 pin on the back of the F3 to the RXI pin of the serial module
using a F/M wire.</li>
<li>Connect the PA10 pin on the back of the F3 to the TXO pin of the serial
module using a F/M wire.</li>
<li>Now connect the USB cable to the F3.</li>
<li>Finally connect the USB cable to the Serial module.</li>
<li>Re-launch OpenOCD and <code>itmdump</code></li>
</ul>
<p>Everything's wired up! Let's proceed to send data back and forth.</p>
<h1>Send a single byte</h1>
<p>Our first task will be to send a single byte from the microcontroller to the
laptop over the serial connection.</p>
<p>This time, I'm going to provide you with an already initialized USART
peripheral. You'll only have to work with the registers that are in charge of
sending data back and forth.</p>
<p>Go into the <code>10-usart</code> directory and let's run the starter code therein. Make
sure that you have minicom/PuTTY open.</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let usart1 = unsafe { peripheral::usart1_mut() };

    // Send a single character
    usart1.tdr.write(|w| w.tdr(u16::from('X' as u8)));

    loop {}
}
</code></pre>
<p>This program writes to the <code>TDR</code> register. This causes the <code>USART</code> peripheral
to send one byte of information through the serial interface.</p>
<p>On the receiving end, your laptop, you should see show the character <code>X</code> appear
on minicom/PuTTY's terminal.</p>
<h1>Send a string</h1>
<p>The next task will be to send a whole string from the micro to your laptop.</p>
<p>I want you to send the string <code>&quot;The quick brown fox jumps over the lazy dog.&quot;</code>
from the micro to your laptop.</p>
<p>It's your turn to write the program.</p>
<p>Execute your program inside the debugger, statement by statement. What do you
see?</p>
<p>Then execute the program in &quot;one go&quot; using the <code>continue</code> command. What happens
this time?</p>
<p>Finally, build the program in &quot;release&quot; mode and, again, run it &quot;one go&quot;. What
happens this time?</p>
<h1>Overruns</h1>
<p>If you wrote your program like this:</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let usart1 = unsafe { peripheral::usart1_mut() };

    // Send a string
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr(u16::from(*byte)));
    }

    unsafe { bkpt!() }

    loop {}
}
</code></pre>
<p>You probably received something like this on your laptop when you executed the
program compiled in debug mode.</p>
<pre><code># minicom's terminal
The uik ron fx ums oerth lzy og
</code></pre>
<p>And if you compiled in release mode, you probably only got something like this:</p>
<pre><code># minicom's terminal
Tq
</code></pre>
<p>What went wrong?</p>
<p>You see, sending bytes over the wire takes a relatively large amount of time. I
already did the math so let me quote myself:</p>
<blockquote>
<p>With a common configuration of 1 start bit, 8 bits of payload, zero stop bits
and a baud rate of 115200 bps one can, in theory, send 12,800 frames of 9 bits
per second. Since each one carries a byte of information that results in a
data rate of 12.8 KB/s.</p>
</blockquote>
<p>Our pangram has a length of 45 bytes. That means it's going to take, at least,
3,500 microseconds (<code>45 bytes / (12,800 bytes/s) = 3,515 us</code>) to send the
string. The processor is working at 8 MHz, where executing an instruction takes
125 nanoseconds, so it's likely going to be done with the <code>for</code> loop is less
than 3,500 microseconds.</p>
<p>We can actually time how long it takes to execute the <code>for</code> loop. There's a
<code>time</code> module in the <code>pg</code> crate that exposes an <code>Instant</code> API that's similar to
the one in <code>std::time</code>.</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    use pg::time::{FREQUENCY, Instant};

    let usart1 = unsafe { peripheral::usart1_mut() };

    let instant = Instant::now();
    // Send a string
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // ticks

    iprintln!(&quot;`for` loop took {} ticks ({} us)&quot;,
              elapsed,
              elapsed as f32 / FREQUENCY as f32 * 1e6);

    unsafe { bkpt!() }

    loop {}
}
</code></pre>
<p>In debug mode, I get:</p>
<pre><code># itmdump's terminal
`for` loop took 21614 ticks (2701.75 us)
</code></pre>
<p>This is less than 3,500 microseconds but it's not that far off and that's why
only a few bytes of information are lost.</p>
<p>In conclusion, the processor is trying to send bytes at a faster rate than what
the hardware can actually handle and this results in data loss. This condition
is known as buffer <em>overrun</em>.</p>
<p>How do we avoid this? The status register (<code>ISR</code>) has a flag, <code>TXE</code>, that
indicates if it's &quot;safe&quot; to write to the <code>TDR</code> register without incurring in
data loss.</p>
<p>Let's use that to slowdown the processor.</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let usart1 = unsafe { peripheral::usart1_mut() };

    let instant = Instant::now();
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        // wait until it's safe to write to TDR
        while !usart1.isr.read().txe() {}

        usart1.tdr.write(|w| w.tdr(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // ticks

    iprintln!(&quot;`for` loop took {} ticks ({} us)&quot;,
              elapsed,
              elapsed as f32 / FREQUENCY as f32 * 1e6);

    unsafe { bkpt!() }

    loop {}
}
</code></pre>
<p>This time, running the program in debug or release mode should result in a
complete string on the receiving side.</p>
<pre><code># minicom/PuTTY's console
The quick brown fox jumps over the lazy dog.
</code></pre>
<p>The timing of the <code>for</code> loop should be closer to the theoretical 3,500
microseconds as well. The timing below is for the &quot;debug&quot; version.</p>
<pre><code># itmdump's console
`for` loop took 30397 ticks (3799.625 us)
</code></pre>
<h1><code>uprintln!</code></h1>
<p>For the next exercise, we'll implement the <code>uprint!</code> family of macros. Your goal
is to make this line of code work:</p>
<pre><code class="language-rust">uprintln!(&quot;The answer is {}&quot;, 40 + 2)
</code></pre>
<p>Which must send the string <code>&quot;The answer is 42&quot;</code> through the serial interface.</p>
<p>How do we go about that? It's informative to look into the <code>std</code> implementation
of <code>println!</code>.</p>
<pre><code class="language-rust">// src/libstd/macros.rs
macro_rules! print {
    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));
}
</code></pre>
<p>Looks simple so far. We need the built-in <code>format_args!</code> macro (it's implement
in the compiler so we can't see what it actually does). We'll have to use that
macro in the exact same way. What does this <code>_print</code> function do?</p>
<pre><code class="language-rust">// src/libstd/io/stdio.rs
pub fn _print(args: fmt::Arguments) {
    let result = match LOCAL_STDOUT.state() {
        LocalKeyState::Uninitialized |
        LocalKeyState::Destroyed =&gt; stdout().write_fmt(args),
        LocalKeyState::Valid =&gt; {
            LOCAL_STDOUT.with(|s| {
                if s.borrow_state() == BorrowState::Unused {
                    if let Some(w) = s.borrow_mut().as_mut() {
                        return w.write_fmt(args);
                    }
                }
                stdout().write_fmt(args)
            })
        }
    };
    if let Err(e) = result {
        panic!(&quot;failed printing to stdout: {}&quot;, e);
    }
}
</code></pre>
<p>That <em>looks</em> complicated but the only part we are interested in is:
<code>w.write_fmt(args)</code> and <code>stdout().write_fmt(args)</code>. What <code>print!</code> ultimately
does is call the <code>fmt::Write::write_fmt</code> method with the output of
<code>format_args!</code> as its argument.</p>
<p>Luckily we don't have to implement the <code>fmt::Write::write_fmt</code> method either
because it's a default method. We only have to implement the
<code>fmt::Write::write_str</code> method.</p>
<p>Let's do that.</p>
<p>This is what the macro side of the equation looks like. What's left to be done
by you is provide the implementation of the <code>write_str</code> method.</p>
<pre><code class="language-rust">macro_rules! uprint {
    ($($arg:tt)*) =&gt; {
        SerialPort{}.write_fmt(format_args!($($arg)*)).ok()
    };
}

macro_rules! uprintln {
    ($fmt:expr) =&gt; {
        uprint!(concat!($fmt, &quot;\n&quot;))
    };
    ($fmt:expr, $($arg:tt)*) =&gt; {
        uprint!(concat!($fmt, &quot;\n&quot;), $($arg)*)
    };
}

struct SerialPort {}

impl Write for SerialPort {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        // TODO implement this
    }
}
</code></pre>
<h1>Receive a single byte</h1>
<p>So far we have sending data from the micro to your laptop. It's time to try the
opposite: receiving data from your laptop.</p>
<p>There's a <code>RDR</code> register that will be filled with the data that comes from the
RX line. If we read that register, we'll retrieve the data that the other side
of the channel sent. The question is: How do we know that we have received (new)
data? The status register (<code>ISR</code>) has a bit for that purpose: <code>RXNE</code>. We can
just busy wait on that flag.</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let usart1 = unsafe { peripheral::usart1_mut() };

    loop {
        // Wait until there's data available
        while !usart1.isr.read().rxne() {}

        // Retrieve the data
        let _byte = usart1.rdr.read().rdr() as u8;

        unsafe { bkpt!() };
    }
}
</code></pre>
<p>Let's try this program! Let it run free using <code>continue</code> and then type a single
character in minicom/PuTTY's console. What happens? What are the contents of the
<code>_byte</code> variable? Try:</p>
<pre><code>(gdb) p/c _byte
</code></pre>
<h1>Echo server</h1>
<p>Let's merge transmission and reception into a single program and write an echo
server. An echo server sends back to the client the same text it sent. For this
application, the microcontroller will be the server and you and your laptop will
be the client.</p>
<p>This should be straightforward to implement. (hint: do it byte by byte)</p>
<h1>Reverse a string</h1>
<p>Alright, next let's make the server more interesting by having it respond to the
client with the reverse of the text that they sent. The server will respond to
the client every time they press the ENTER key. Each server response will be
in a new line.</p>
<p>This time you'll need a buffer; you can use <code>FixedVec</code>. Here's the starter code:</p>
<pre><code class="language-rust">#[macro_use]
extern crate fixedvec;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    use fixedvec::{FixedVec, Result};

    let usart1 = unsafe { peripheral::usart1_mut() };

    let mut memory = alloc_stack!([u8; 32]);
    let mut buffer = FixedVec::new(&amp;mut memory);
    loop {
        buffer.clear();

        // TODO Receive a user request. Each user request ends with ENTER
        // NOTE `buffer.push` returns a `Result`. Handle the error by responding
        // with an error message.

        // TODO Send back the reversed string
    }
}
</code></pre>
<h1>My solution</h1>
<pre><code class="language-rust">#![no_main]
#![no_std]

#[macro_use]
extern crate fixedvec;

#[macro_use]
extern crate pg;

use fixedvec::{FixedVec, Result};
use pg::peripheral;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let usart1 = unsafe { peripheral::usart1_mut() };

    let mut memory = alloc_stack!([u8; 32]);
    let mut buffer = FixedVec::new(&amp;mut memory);
    loop {
        // Receive
        buffer.clear();
        match (|| -&gt; Result&lt;()&gt; {
            loop {
                while !usart1.isr.read().rxne() {}
                let byte = usart1.rdr.read().rdr() as u8;

                try!(buffer.push(byte));

                // Carriage return
                if byte == 13 {
                    break;
                }
            }

            Ok(())
        })() {
            Err(_) =&gt; {
                for byte in b&quot;error: buffer overflow\n\r&quot; {
                    while !usart1.isr.read().txe() {}
                    usart1.tdr.write(|w| w.tdr(u16::from(*byte)));
                }
            }
            Ok(_) =&gt; {
                // Respond
                for byte in buffer.iter()
                    .rev()
                    .chain(&amp;['\n' as u8, '\r' as u8]) {
                    while !usart1.isr.read().txe() {}
                    usart1.tdr.write(|w| w.tdr(u16::from(*byte)));
                }
            }
        }
    }
}
</code></pre>
<h1>Bluetooth setup</h1>
<p>It's time to get rid of some wires. Serial communication can not only be
emulated on top of the USB protocol; it can also be emulated on top of the
Bluetooth protocol. This serial over Bluetooth protocol is known as RFCOMM.</p>
<p>Before we use the Bluetooth module with the microcontroller, let's first
interact with it using minicom/PuTTY.</p>
<p>The first thing we'll need to do is: turn on the Bluetooth module. We'll have to
share some of the F3 power to it using the following connection:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (power only)" src="assets/f3-bluetooth-power-only.png">
</p>
<p>The recommend steps to wire this up are:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code></li>
<li>Disconnect the USB cables from the F3 and the serial module.</li>
<li>Connect F3's GND pin to the Bluetooth's GND pin using a Female / Female (F/F)
wire. Preferably, a black one.</li>
<li>Connect F3's 5V pin to the Bluetooth's VCC pin using a F/F wire. Preferably, a
red one.</li>
<li>Then, connect the USB cable back to the F3.</li>
<li>Re-launch OpenOCD and <code>itmdump</code></li>
</ul>
<p>Two LEDs, a blue one and a red one, on the Bluetooth module should start
blinking right after you power on the F3 board.</p>
<p>Next thing to do is pair your laptop and the Bluetooth module. AFAIK, Windows
and mac users can simply use their OS default Bluetooth manager to do the
pairing. The Bluetooth module default pin is 1234.</p>
<p>Linux users will have to follow (some of) <a href="11-bluetooth-setup/linux.html">these instructions</a>.</p>
<h1>Linux</h1>
<p>If you have a graphical Bluetooth manager, you can use that to pair your laptop
to the Bluetooth module and skip most of these steps. You'll probably still have
to <a href="11-bluetooth-setup/linux.html#rfcomm%20device">this step</a> tough.</p>
<h2>Power up</h2>
<p>First, your laptop's Bluetooth transceiver may be OFF. Check its status with
<code>hciconfig</code> and turn it ON if necessary:</p>
<pre><code>$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        DOWN  &lt;--
        RX bytes:580 acl:0 sco:0 events:31 errors:0
        TX bytes:368 acl:0 sco:0 commands:30 errors:0

$ sudo hciconfig hci0 up

$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        UP RUNNING  &lt;--
        RX bytes:1190 acl:0 sco:0 events:67 errors:0
        TX bytes:1072 acl:0 sco:0 commands:66 errors:0
</code></pre>
<p>Then you need to launch the BlueZ (Bluetooth) daemon:</p>
<ul>
<li>On systemd based Linux distributions, use:</li>
</ul>
<pre><code>$ sudo systemctl start bluetooth
</code></pre>
<ul>
<li>On Ubuntu (or upstart based Linux distributions), use:</li>
</ul>
<pre><code>$ sudo /etc/init.d/bluetooth start
</code></pre>
<p>You may also need to unblock your Bluetooth, depending on what <code>rfkill list</code>
says:</p>
<pre><code>$ rkfill list
9: hci0: Bluetooth
        Soft blocked: yes &lt;--
        Hard blocked: no

$ sudo rfkill unblock bluetooth

$ rkfill list
9: hci0: Bluetooth
        Soft blocked: no &lt;--
        Hard blocked: no

</code></pre>
<h2>Scan</h2>
<pre><code>$ hcitool scan
Scanning ...
        20:16:05:XX:XX:XX       Ferris
                                ^^^^^^
</code></pre>
<h2>Pair</h2>
<pre><code>$ bluetoothctl
[bluetooth]# scan on
[bluetooth]# agent on
[bluetooth]# pair 20:16:05:XX:XX:XX
Attempting to pair with 20:16:05:XX:XX:XX
[CHG] Device 20:16:05:XX:XX:XX Connected: yes
Request PIN code
[agent] Enter PIN code: 1234
</code></pre>
<h2>rfcomm device</h2>
<p>We'll create a device file for our Bluetooth module in <code>/dev</code>. Then we'll be
able to use it just like we used <code>/dev/ttyUSB0</code>.</p>
<pre><code>$ sudo rfcomm bind 0 20:16:05:XX:XX:XX
</code></pre>
<p>Because we used <code>0</code> as an argument to <code>bind</code>, <code>/dev/rfcomm0</code> will be the device
file assigned to our Bluetooth module.</p>
<p>You can release (destroy) the device file at any time with the following
command:</p>
<pre><code># Don't actually run this command right now
$ sudo rfcomm release 0
</code></pre>
<h1>Loopback, again</h1>
<p>After pairing your laptop to the Bluetooth module, your OS should have create a
device file / COM port for you. On Linux, it should be <code>/dev/rfcomm*</code>; on mac,
it should be <code>/dev/cu.*</code> and on Windows, it should be a new COM port.</p>
<p>We can now test the Bluetooth module with minicom/PuTTY. Because this module
doesn't have LED indicators for the transmission and reception events like the
serial module did, we'll test the module using a loopback connection:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (loopback)" src="assets/f3-bluetooth-loopback.png">
</p>
<p>Just connect the module's TXD pin to its RXD pin using a F/F wire.</p>
<p>Now, connect to the device using <code>minicom</code>/<code>PuTTY</code>:</p>
<pre><code>$ minicom -D /dev/rfcomm0
</code></pre>
<p>Upon connecting, the blinking pattern of the Bluetooth module should change to:
long pause then blink twice quickly.</p>
<p>Typing inside minicom/PuTTY terminal should echo back what you type.</p>
<h1>Serial over Bluetooth</h1>
<p>Now that we verify that the Bluetooth module works with minicom/PuTTY, let's
connect it to the microcontroller:</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection" src="assets/f3-bluetooth.png">
</p>
<p>Recommended steps to wire this up:</p>
<ul>
<li>Close OpenOCD and <code>itmdump</code>.</li>
<li>Disconnect the F3 from your laptop.</li>
<li>Connect F3's GND pin to the module's GND pin using a Female/Female (F/F) wire
(preferably, a black one).</li>
<li>Connect F3's 5V pin to the module's VCC pin using a F/F wire (preferably, a
red one).</li>
<li>Connect the PA9 (TX) pin on the back of the F3 to the Bluetooth's RXD pin
using a F/F wire.</li>
<li>Connect the PA10 (RX) pin on the back of the F3 to the Bluetooth's TXD pin
using a F/F wire.</li>
<li>Now connect the F3 and your laptop using an USB cable.</li>
<li>Re-launch OpenOCD and <code>itmdump</code>.</li>
</ul>
<p>And that's it! You should be able to run all the programs you wrote in <a href="10-usart/README.html">section
10</a> without modification! Just make sure you open the right serial device / COM
port.</p>
<h1>I2C</h1>
<p>We just saw the &quot;serial&quot; communication protocol. It's a widely used protocol
because it's very simple and this simplicity makes it easy to implement on top
of other protocols like Bluetooth and USB.</p>
<p>However, it's simplicity is also a downside. More elaborated data exchanges,
like reading a digital sensor, would require the sensor vendor to come up with
another protocol on top of it.</p>
<p>(Un)Luckily for us, there are <em>plenty</em> of other communication protocols in the
embedded space. Some of them are widely used in digital sensors.</p>
<p>The F3 board we are using has three motion sensors in it: an accelerometer, a
magnetometer and gyroscope. The accelerometer and magnetometer are packaged in a
single component and can be accessed via an I2C bus.</p>
<p>I2C stands for Inter-Integrated Circuit and is a <em>synchronous</em> <em>serial</em>
communication protocol. It uses two lines to exchange data: a data line (SDA)
and a clock line (SCL). Because a clock line is used to synchronize the
communication, this is a <em>synchronous</em> protocol.</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<p>This protocol uses a <em>&quot;master&quot;</em> / <em>&quot;slave&quot;</em> model where the &quot;master&quot; is the
device that <em>starts</em> and drives the communication with a &quot;slave&quot; device. Several
devices, both &quot;masters&quot; and &quot;slaves&quot;, can be connected to the same bus at the
same time. A master device can communicate with a specific slave device by first
broadcasting its <em>address</em> to the bus. These address can be 7 bits or 10 bits
long. Once a master has <em>started</em> a communication with a slave, no other device
can make use of the bus until the master <em>stops</em> the communication.</p>
<p>The clock line determines how fast data can be exchanged and it usually operates
at a frequency of 100 KHz (standard mode) or 400 KHz (fast mode).</p>
<h2>Functional description</h2>
<h2>LSM303DLHC specific protocol</h2>
<blockquote>
<p>I2C operation - Section 5.1.1 - Page 20 - LSM303DLHC</p>
</blockquote>
<h2>Reading registers</h2>
<blockquote>
<p>I2C registers - Section 28.7 - Page 873 - Reference Manual</p>
</blockquote>
<p>Read a single register. Each register is one byte.</p>
<pre><code>(gdb) next # several times

(gdb) p/t byte
$1 = 1001000
</code></pre>
<p>Receive several bytes.</p>
<h1>General protocol</h1>
<p>The I2C protocol is more elaborated than the &quot;serial&quot; communication protocol
because it has to support communication between several devices. Let's see how
it works using examples:</p>
<h2><strong>M</strong>aster -&gt; <strong>S</strong>lave</h2>
<p>If the master wants to send data to the slave:</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<ol>
<li>M: Broadcast START</li>
<li>M: Broadcast slave address (7 bits) + the R/W (8th) bit set to WRITE</li>
<li>S: Responds ACK (ACKnowledgement)</li>
<li>M: Send one byte</li>
<li>S: Responds ACK</li>
<li>Repeat (4+5) zero or more times</li>
<li>M: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The slave address could have been 10 bits instead of 7 bits long.
Nothing else would have changed.</p>
</blockquote>
<h2><strong>M</strong>aster &lt;- <strong>S</strong>lave</h2>
<p>If the master wants to read data from the slave:</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<ol>
<li>M: Broadcast START</li>
<li>M: Broadcast slave address (7 bits) + the R/W (8th) bit set to READ</li>
<li>S: Responds with ACK</li>
<li>S: Send byte</li>
<li>M: Responds with ACK</li>
<li>repeat (4+5) zero or more times</li>
<li>M: Broadcast STOP OR (broadcast RESTART and go back to (2))</li>
</ol>
<blockquote>
<p><strong>NOTE</strong> The slave address could have been 10 bits instead of 7 bits long.
Nothing else would have changed.</p>
</blockquote>
<h1>LSM303DLHC</h1>
<p>Two of the sensors in the F3, the magnetometer and the accelerometer, are
packaged in a single component: the LSM303DLHC integrated circuit. These two
sensors can be accessed via an I2C bus. Each sensor behaves like a I2C slaves
and has a <em>different</em> address.</p>
<p>Each sensor has its own memory where it stores the results of sensing its
environment. Our interaction with these sensors will mainly involve reading
their memory.</p>
<p>The memory of these sensors is modeled as byte addressable registers. These
sensors can be configured too; that's done by writing to their registers. So, in
a sense, these sensors are very similar to the peripherals <em>inside</em> the
microcontroller. The difference is that their registers are not mapped into the
microcontrollers' memory. Instead, their registers have to be accessed via the
I2C bus.</p>
<p>The main source of information about the LSM303DLHC is its <a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">Data Sheet</a>. Let's
read through it to see how one can read the sensors' registers. That part is in:</p>
<blockquote>
<p>Section 5.1.1 I2C Operation - Page 20 - LSM303DLHC Data Sheet</p>
</blockquote>
<p>The other part of the documentation relevant to this workshop is the description
of the registers. That part is in</p>
<blockquote>
<p>Section 7 Register description - Page 25 - LSM303DLHC Data Sheet</p>
</blockquote>
<h1>Read a single register</h1>
<p>Let's put all that theory into practice!</p>
<p>Just like with the USART peripheral, I've took care of initializing everything
before you reach <code>main</code> so you'll only have to deal with the following
registers:</p>
<ul>
<li><code>CR2</code>. Control register 2.</li>
<li><code>ISR</code>. Interrupt and status register.</li>
<li><code>TXDR</code>. Transmit data register.</li>
<li><code>RXDR</code>. Receive data register.</li>
</ul>
<p>These registers are documented in the following section of the Reference Manual:</p>
<blockquote>
<p>Section 28.7 I2C registers - Page 873 - Reference Manual</p>
</blockquote>
<p>We'll be using the <code>I2C1</code> peripheral in conjunction with pins <code>PB6</code> (<code>SCL</code>) and
<code>PB7</code> (<code>SDA</code>).</p>
<p>You won't have to wire anything this time because the sensor is on the board and
it's already connected to the microcontroller. However, I do would recommend
that you disconnect the serial / Bluetooth module from the F3 to make it
easier to manipulate. Later on, we'll be moving the board around quite a bit.</p>
<p>Your task is to write a program that reads the contents of the magnetometer's
<code>IRA_REG_M</code> register. This register is read only and always contains the value
<code>0b01001000</code>.</p>
<p>The microcontroller will be taking the role of the I2C master and the
magnetometer inside the LSM303DLHC will be the I2C slave.</p>
<p>Here's the starter code. You'll have to implement the <code>TODO</code>s.</p>
<pre><code class="language-rust">// Slave address
const MAGNETOMETER: u8 = 0b001_1110;

// Addresses of the magnetometer's registers
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let i2c1 = unsafe { peripheral::i2c1_mut() };

    // Stage 1: Send the address of the register we want to read to the
    // magnetometer
    {
        // TODO Broadcast START

        // TODO Broadcast the MAGNETOMETER address with the R/W bit set to Write

        // TODO Send the address of the register that we want to read: IRA_REG_M
    }

    // Stage 2: Receive the contents of the register we asked for
    let byte = {
        // TODO Broadcast RESTART

        // TODO Broadcast the MAGNETOMETER address with the R/W bit set to Read

        // TODO Receive the contents of the register

        // TODO Broadcast STOP
    };

    // Expected output: 0x0A - 0b01001000
    iprintln!(&quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}
</code></pre>
<p>To give you some extra help, these are the exact bits you'll be working with:</p>
<ul>
<li><code>CR2</code>: <code>SADD1</code>, <code>RD_WRN</code>, <code>NBYTES</code>, <code>START</code>, <code>AUTOEND</code></li>
<li><code>ISR</code>: <code>TXIS</code>, <code>RXNE</code>, <code>TC</code></li>
<li><code>TXDR</code>: <code>TXDATA</code></li>
<li><code>RXDR</code>: <code>RXDATA</code></li>
</ul>
<h1>The solution</h1>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let i2c1 = unsafe { peripheral::i2c1_mut() };

    // Stage 1: Send the address of the register we want to read to the
    // magnetometer
    {
        // Broadcast START
        // Broadcast the MAGNETOMETER address with the R/W bit set to Write
        i2c1.cr2.write(|w| {
            w.start(true)
                .sadd1(MAGNETOMETER)
                .rd_wrn(false)
                .nbytes(1)
                .autoend(false)
        });

        // Wait until we can send more data
        while !i2c1.isr.read().txis() {}

        // Send the address of the register that we want to read: IRA_REG_M
        i2c1.txdr.write(|w| w.txdata(IRA_REG_M));

        // Wait until the previous byte has been transmitted
        while !i2c1.isr.read().tc() {}
    }

    // Stage 2: Receive the contents of the register we asked for
    let byte = {
        // Broadcast RESTART
        // Broadcast the MAGNETOMETER address with the R/W bit set to Read
        i2c1.cr2
            .modify(|_, w| w.start(true).nbytes(1).rd_wrn(true).autoend(true));

        // Wait until we have received the contents of the register
        while !i2c1.isr.read().rxne() {}

        // Broadcast STOP (automatic because of `AUTOEND = 1`)

        i2c1.rxdr.read().rxdata()
    };

    // Expected output: 0x0A - 0b01001000
    iprintln!(&quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}
</code></pre>
<h1>Read several registers</h1>
<p>Reading the <code>IRA_REG_M</code> register was a good test of our understanding of the I2C
protocol but that register contains uninteresting information.</p>
<p>This time, we'll read the registers of the magnetometer that actually expose the
sensor readings. Six contiguous registers are involved and they start with
<code>OUT_X_H_M</code> at address <code>0x03</code>.</p>
<p>We'll modify our previous program to read these six registers. Only a few
modifications are needed.</p>
<p>We'll need to change the address we request from the magnetometer from
<code>IRA_REG_M</code> to <code>OUT_X_H_M</code>.</p>
<pre><code>// Send the address of the register that we want to read: OUT_X_H_M
i2c1.txdr.write(|w| w.txdata(OUT_X_H_M));
</code></pre>
<p>We'll have to request the slave for six bytes rather than just one.</p>
<pre><code class="language-rust">// Broadcast RESTART
// Broadcast the MAGNETOMETER address with the R/W bit set to Read
i2c1.cr2.modify(|_, w| w.start(true).nbytes(6).rd_wrn(true).autoend(true));
</code></pre>
<p>And fill a buffer rather than read just one byte:</p>
<pre><code class="language-rust">let mut buffer = [0u8; 6];
for byte in &amp;mut buffer {
    // Wait until we have received the contents of the register
    while !i2c1.isr.read().rxne() {}

    *byte = i2c1.rxdr.read().rxdata();
}
// Broadcast STOP (automatic because of `AUTOEND = 1`)
</code></pre>
<p>Putting it all together inside a loop alongside a delay to reduce the data
throughput:</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let i2c1 = unsafe { peripheral::i2c1_mut() };

    loop {
        // Broadcast START
        // Broadcast the MAGNETOMETER address with the R/W bit set to Write
        i2c1.cr2.write(|w| {
            w.start(true)
                .sadd1(MAGNETOMETER)
                .rd_wrn(false)
                .nbytes(1)
                .autoend(false)
        });

        // Wait until we can send more data
        while !i2c1.isr.read().txis() {}

        // Send the address of the register that we want to read: IRA_REG_M
        i2c1.txdr.write(|w| w.txdata(OUT_X_H_M));

        // Wait until the previous byte has been transmitted
        while !i2c1.isr.read().tc() {}

        // Broadcast RESTART
        // Broadcast the MAGNETOMETER address with the R/W bit set to Read
        i2c1.cr2
            .modify(|_, w| w.start(true).nbytes(6).rd_wrn(true).autoend(true));

        let mut buffer = [0u8; 6];
        for byte in &amp;mut buffer {
            // Wait until we have received something
            while !i2c1.isr.read().rxne() {}

            *byte = i2c1.rxdr.read().rxdata();
        }
        // Broadcast STOP (automatic because of `AUTOEND = 1`)

        iprintln!(&quot;{:?}&quot;, buffer);

        delay::ms(1_000);
    }
}
</code></pre>
<p>If you run this, you should printed in the <code>itmdump</code>'s console a new array of
six bytes every second. The values within the array should change if you move
around the board.</p>
<pre><code># `itmdump`'s console
[0, 135, 255, 215, 0, 203]
[0, 140, 255, 213, 0, 198]
[0, 138, 255, 215, 0, 201]
[0, 136, 255, 215, 0, 202]
[0, 168, 255, 215, 0, 179]
[1, 39, 255, 223, 0, 73]
[1, 106, 255, 213, 255, 196]
[1, 123, 255, 186, 255, 74]
</code></pre>
<p>But these bytes don't make much sense like that. Let's turn them into actual
readings:</p>
<pre><code class="language-rust">let x_h = u16::from(buffer[0]);
let x_l = u16::from(buffer[1]);
let z_h = u16::from(buffer[2]);
let z_l = u16::from(buffer[3]);
let y_h = u16::from(buffer[4]);
let y_l = u16::from(buffer[5]);

let x = ((x_h &lt;&lt; 8) + x_l) as i16;
let y = ((y_h &lt;&lt; 8) + y_l) as i16;
let z = ((z_h &lt;&lt; 8) + z_l) as i16;

iprintln!(&quot;{:?}&quot;, (x, y, z));
</code></pre>
<p>Now it should look better:</p>
<pre><code>(363, -179, -111)
(362, -182, -111)
(363, -181, -110)
(356, -163, -99)
(342, -12, -47)
(302, 77, -29)
(197, 176, -37)
(77, 218, -44)
(-25, 220, -53)
</code></pre>
<p>This is the Earth's magnetic field decomposed alongside the XYZ axis of the
magnetometer.</p>
<p>In the next section, we'll learn how to make sense of these numbers.</p>
<h1>LED compass</h1>
<p>In this section, we'll implement a compass using the LEDs on the F3. Like proper
compasses, our LED compass must point north somehow. It will do that by turning
on one of its eight LEDs; that LED should point towards north.</p>
<p>Magnetic fields have both a magnitude, measured in Gauss or Teslas, and a
<em>direction</em>. The magnetometer on the F3 measures both the magnitude and the
direction of an external magnetic field but it reports back the <em>decomposition</em>
of said field along <em>its axes</em>.</p>
<p>See below, the magnetometer has three axes associated to it.</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="assets/f3-lsm303dlhc.png">
</p>
<p>Only the X and Y axes are shown above. The Z axis is pointing &quot;out&quot; of your
screen.</p>
<p>Let's get familiar with the readings of the magnetometer by running the
following starter code:</p>
<pre><code class="language-rust">#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        iprintln!(&quot;{:?}&quot;, lsm303dlhc::magnetic_field());
        delay::ms(1_000);
    }
}
</code></pre>
<p>This <code>lsm303dlhc</code> module provides high level API over the LSM303DLHC. Under the
hood it does the same I2C routine that you implemented in the last section but
it reports the X, Y and Z values in a <code>I16x3</code> struct instead of a tuple.</p>
<p>Locate where north is at your current location. Then rotate the board such that
it's aligned &quot;towards north&quot;: its <code>North</code> LED should be pointing towards north.</p>
<p>Now run the starter code and observe the output. What X, Y and Z values do you
see?</p>
<pre><code># itmdump's console
(..)
I16x3 { x: 322, y: 24, z: -11 }
I16x3 { x: 323, y: 24, z: -13 }
I16x3 { x: 324, y: 23, z: -12 }
I16x3 { x: 324, y: 20, z: -10 }
</code></pre>
<p>Now rotate the board 180 degrees. What X, Y and Z values do you see this time?</p>
<p>Finally, rotate the board 90 degrees clockwise. The <code>East</code> LED should be
pointing north this time. What X, Y and Z values do you see this time?</p>
<h1>Take 1</h1>
<p>What's the simplest way in which we can implement the LED compass? Even if it's
not perfect.</p>
<p>For starters, we'd only care about the X and Y components of the magnetic field
because when you look at a compass you always hold it in horizontal position
thus the compass is in the XY plane.</p>
<p>For example, what LED would you turn on in the following case. EMF stands for
Earth's Magnetic Field and green arrow has the direction of the EMF (it points
north).</p>
<p align="center">
<img title="Quadrant I" src="assets/quadrant-i.png">
</p>
<p>The <code>SouthEast</code> LED, right?</p>
<p>What <em>signs</em> do the X and Y components of the magnetic field have in that
scenario? Both are positive.</p>
<p>If we only looked at the signs of the X and Y components we could determine to
which quadrant the magnetic field belongs to.</p>
<p align="center">
<img title="Quadrants" src="assets/quadrants.png">
</p>
<p>In the previous example, the magnetic field was in the first quadrant (x and y
were positive) and it made sense to turn on the <code>SouthEast</code> LED. Similarly, we
could turn a different LED if the magnetic field was in a different quadrant.</p>
<p>Let's try that logic. Here's the starter code:</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

use pg::I16x3;
use pg::led::Direction;
use pg::{delay, led, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        let I16x3 { x, y, .. } = lsm303dlhc::magnetic_field();

        // Look at the signs of the X and Y components to determine in which
        // quadrant the magnetic field is
        let dir = match (x &gt; 0, y &gt; 0) {
            // Quadrant I
            (true, true) =&gt; Direction::SouthEast,
            // Quadrant II
            (false, true) =&gt; { /* TODO */ },
            // Quadrant III
            (false, false) =&gt; { /* TODO */ },
            // Quadrant IV
            (true, false) =&gt; { /* TODO */ },
        };

        led::all_off();
        dir.on();

        delay::ms(100);
    }
}
</code></pre>
<p>There's a <code>Direction</code> enum in the <code>led</code> module that has 8 variants named after
the cardinal points: <code>North</code>, <code>East</code>, <code>SouthWest</code>, etc. Each of these variants
represent one of the 8 LEDs in the compass. The <code>Direction</code> <code>enum</code> exposes <code>on</code>
and <code>off</code> methods like the <code>Led</code> struct does so you can use it to turn on/off
the LED that's associated to that particular cardinal point.</p>
<h1>Solution 1</h1>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

use pg::I16x3;
use pg::led::Direction;
use pg::{delay, led, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        let I16x3 { x, y, .. } = lsm303dlhc::magnetic_field();

        let dir = match (x &gt; 0, y &gt; 0) {
            (false, false) =&gt; Direction::NorthWest,
            (false, true) =&gt; Direction::NorthEast,
            (true, false) =&gt; Direction::SouthWest,
            (true, true) =&gt; Direction::SouthEast,
        };

        led::all_off();
        dir.on();

        delay::ms(100);
    }
}
</code></pre>
<h1>Take 2</h1>
<p>This time, we'll use math to get the precise angle that the magnetic field forms
with the X and Y axes of the magnetometer.</p>
<p>We'll use the <code>atan2</code> function. This function returns an angle in the <code>-PI</code> to
<code>PI</code> range. The graphic below shows how this angle is measured:</p>
<p align="center">
<img title="atan2" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Atan2_60.svg">
</p>
<p>Here's the starter code. <code>theta</code> has already been computed. You need to pick
which LED to turn on based on the value of <code>theta</code>.</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate m;

#[macro_use]
extern crate pg;

// you'll find this useful ;-)
use core::f32::consts::PI;

// this trait provides the `atan2` method
use m::Float;
use pg::I16x3;
use pg::led::Direction;
use pg::{delay, led, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        let I16x3 { x, y, .. } = lsm303dlhc::magnetic_field();

        let theta = (y as f32).atan2(x as f32);  // radians

        // TODO pick a direction to point to based on `theta`

        led::all_off();
        dir.on();

        delay::ms(100);
    }
}
</code></pre>
<p>Suggestions/tips:</p>
<ul>
<li>A whole circle rotation equals 360 degrees.</li>
<li><code>PI</code> radians is equivalent to 180 degrees.</li>
<li>If <code>theta</code> was zero, what LED would you turn on?</li>
<li>If <code>theta</code> was, instead, very close to zero, what LED would you turn on?</li>
<li>If <code>theta</code> kept increasing, at what value would you turn on a different LED?</li>
</ul>
<h1>Solution 2</h1>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate m;

#[macro_use]
extern crate pg;

use core::f32::consts::PI;

use m::Float;
use pg::I16x3;
use pg::led::Direction;
use pg::{delay, led, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        let I16x3 { x, y, .. } = lsm303dlhc::magnetic_field();

        let theta = (y as f32).atan2(x as f32);

        let dir = if theta &lt; -7. * PI / 8. {
            Direction::North
        } else if theta &lt; -5. * PI / 8. {
            Direction::NorthWest
        } else if theta &lt; -3. * PI / 8. {
            Direction::West
        } else if theta &lt; -PI / 8. {
            Direction::SouthWest
        } else if theta &lt; PI / 8. {
            Direction::South
        } else if theta &lt; 3. * PI / 8. {
            Direction::SouthEast
        } else if theta &lt; 5. * PI / 8. {
            Direction::East
        } else if theta &lt; 7. * PI / 8. {
            Direction::NorthEast
        } else {
            Direction::North
        };

        led::all_off();
        dir.on();

        delay::ms(100);
    }
}
</code></pre>
<h1>Magnitude</h1>
<p>We have been working with the direction of the magnetic field but what's its
real magnitude? The number that the <code>magnetic_field</code> function reports are
unit-less. How can we convert those values to Gauss?</p>
<p>The documentation will answer that question.</p>
<blockquote>
<p>Section 2.1 Sensor characteristics - Page 10 - LSM303DLHC Data Sheet</p>
</blockquote>
<p>The table in that page shows a &quot;magnetic gain setting&quot; that has different values
according to the values of the GN bits. By default, those GN bits are set to
<code>001</code>. That means that magnetic gain of the X and Y axes is <code>1100 LSB / Gauss</code>
and the magnetic gain of the Z axis is <code>980 LSB / Gauss</code>. LSB stands for Least
Significant Bits and the <code>1100 LSB / Gauss</code> number indicates that a reading of
<code>1100</code> is equivalent to <code>1 Gauss</code>, a reading of <code>2200</code> is equivalent to 2 Gauss
and so on.</p>
<p>So, what we need to do is divide the X, Y and Z values that the sensor outputs
by its corresponding &quot;gain&quot;. Then, we'll have the X, Y and Z components of the
magnetic field in Gauss.</p>
<p>With some extra math we can retrieve the magnitude of the magnetic field from
its X, Y and Z components:</p>
<pre><code class="language-rust">let magnitude = (x * x + y * y + z * z).sqrt();
</code></pre>
<p>Putting all this together in a program:</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate m;

#[macro_use]
extern crate pg;

use m::Float;
use pg::I16x3;
use pg::lsm303dlhc;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub fn main() -&gt; ! {
    const XY_GAIN: f32 = 1100.; // LSB / G
    const Z_GAIN: f32 = 980.; // LSB / G

    loop {
        let I16x3 { x, y, z } = lsm303dlhc::magnetic_field();
        let x = f32::from(x) / XY_GAIN;
        let y = f32::from(y) / XY_GAIN;
        let z = f32::from(z) / Z_GAIN;

        let mag = (x * x + y * y + z * z).sqrt();

        iprintln!(&quot;{} mG&quot;, mag * 1_000.);
    }
}
</code></pre>
<p>This program will report the magnitude of the magnetic field in milligauss
(<code>mG</code>) because the magnitude of the Earth's magnetic field is in the range of
<code>250 mG</code> to <code>650 mG</code> (the magnitude varies depending on your geographical
location).</p>
<p>Some questions:</p>
<p>Without moving the board, what value do you see? Do you always see the same
value?</p>
<p>If you rotate the board, does the magnitude change? Should it change?</p>
<h1>Calibration</h1>
<p>If we rotate the board, the direction of the Earth's magnetic field with respect
to the magnetometer should change but its magnitude should not! Yet, the
magnetometer indicates that the magnitude of the magnetic field changes as the
board rotates.</p>
<p>Why's that the case? Turns out the magnetometer needs to be calibrated to return
the correct answer.</p>
<p>The calibration involves quite a bit of math (matrices) so we won't cover it in
this workshop but this <a href="http://cache.freescale.com/files/sensors/doc/app_note/AN4246.pdf">Application Note</a> describes the procedure if you are
interested. Instead, what we'll do in this section is &quot;visualize&quot; how off we
are.</p>
<p>Let's try this experiment: Let's record the readings of the magnetometer while
we slowly rotate the board along the Z axis while keeping the board horizontal
in the XY plane. We'll use the <code>iprintln</code> macro to format the readings as Tab
Separated Values (TSV).</p>
<pre><code class="language-rust">pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        let I16x3 { x, y, z } = lsm303dlhc::magnetic_field();

        iprintln!(&quot;{}\t{}\t{}&quot;, x, y, z);

        delay::ms(100);
    }
}
</code></pre>
<p>You should get an output in the console that looks like this:</p>
<pre><code>-331    -114    -2
-325    -147    12
-321    -169    10
-307    -209    7
-305    -216    3
-298    -236    8
-293    -243    5
-284    -257    2
-281    -263    1
-270    -278    9
</code></pre>
<p>You can pipe that to a file using:</p>
<pre><code># Careful! Exit any running GDB session and any `itmdump` instance that may be
# using `itm.txt`
$ itmdump itm.txt &gt; emf.txt
</code></pre>
<p>Then import that TSV file into a spreadsheet program and plot the first two
columns as a scatter plot.</p>
<p align="center">
<img title="Earth's magnetic field" src="assets/earth-magnetic-field.png">
</p>
<p>If you rotated the board on a flat horizontal surface, the Z component of the
magnetic field should have remained relatively constant and this plot should
have been a circle (not a ellipse) centered at the origin. Severe deviations
from that indicate that the magnetometer needs to be calibrated.</p>
<p>Take home message: Don't just trust the reading of a sensor. Verify it's
outputting sensible values. If it's not, then calibrate it.</p>
<h1>Punch-o-meter</h1>
<p>In this section we'll be playing with the accelerometer that's in the board.</p>
<p>What are we build this time? A punch-o-meter! We'll be measuring the power of
your jabs. Well, actually the maximum acceleration that you can reach because
acceleration is what accelerometers measure. Strength and acceleration are
proportional though so it's a good approximation.</p>
<p>The accelerometer is also built inside the LSM303DLHC package. And just like the
magnetometer, it can also be accessed using the I2C bus. It also has the same
coordinate system as the magnetometer. Here's the coordinate system again:</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="assets/f3-lsm303dlhc.png">
</p>
<p>Just like in the previous unit, we'll be using a high level API to directly get
the sensor reading in a nicely packaged <code>struct</code>.</p>
<h1>Gravity is up?</h1>
<p>What's the first thing we'll do?</p>
<p>Perform a sanity check!</p>
<p>The starter code prints the X, Y and Z components of the acceleration measured
by the accelerometer. The values have already been &quot;scaled&quot; and have units of
<code>g</code>s. Where <code>1 g</code> is equal to the acceleration of the gravity, about <code>9.8</code>
meters per second squared.</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

use pg::I16x3;
use pg::{delay, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    loop {
        const SENSITIVITY: f32 = 8. / ((1 &lt;&lt; 15) as f32); // mg / LSB

        let I16x3 { x, y, z } = lsm303dlhc::acceleration();

        let x = f32::from(x) * SENSITIVITY;
        let y = f32::from(y) * SENSITIVITY;
        let z = f32::from(z) * SENSITIVITY;

        iprintln!(&quot;{:?}&quot;, (x, y, z));

        delay::ms(1_000);
    }
}
</code></pre>
<p>The output of this program with the board sitting still is:</p>
<pre><code># itmdump's console
(0, 0, 1.03125)
(0, 0, 1.015625)
(0, 0, 1.03125)
</code></pre>
<p>Which is weird because the board is not moving yet its acceleration is non-zero.
What's going on? This must be related to the gravity, right? Because the
acceleration of gravity is <code>1 g</code>. But the gravity pulls objects downwards so the
acceleration along the Z axis should be negative not positive ...</p>
<p>Did the program get the Z axis backwards? Nope, you can test rotating the board
to align the gravity to the X or Y axis but the acceleration measured by the
accelerometer is always pointing up.</p>
<p>What happens here is that the accelerometer is measuring the &quot;proper&quot;
acceleration of the board not the acceleration <em>you</em> are observing. This proper
acceleration is the acceleration of the board as seen from a observer that's in
free fall. An observer that's in free fall is moving toward the center of the
the Earth with an acceleration of <code>1 g</code> but from its point of view the board is
actually moving upwards (away from the center of the Earth) with an acceleration
of <code>1 g</code>. And that's why the proper acceleration is pointing up. This also means
that if the board was in free fall, the accelerometer would report a &quot;proper&quot;
acceleration of zero. Please, don't try that home.</p>
<p>Yes, physics is hard. Let's move on.</p>
<h1>The challenge</h1>
<p>To keep things simple, we'll measure the acceleration only in the X axis while
the board remains horizontal. That way we won't have to deal with subtracting
that &quot;fictitious&quot; <code>1 g</code> we observed before which would be hard because that <code>1 g</code> could have X Y Z components depending on how the board is oriented.</p>
<p>Here's what the punch-o-meter must do:</p>
<ul>
<li>By default, the app is not &quot;observing&quot; the acceleration of the board.</li>
<li>When a significant X acceleration is detected (i.e. the acceleration goes
above some threshold), the app should start a new measurement.</li>
<li>During that measurement interval, the app should keep track of the maximum
acceleration observed</li>
<li>After the measurement interval ends, the app must report the maximum
acceleration observed. You can report the value using the <code>iprintln</code> macro.</li>
</ul>
<p>Give it a try and let me know how hard you can punch <code>;-)</code>.</p>
<h1>My solution</h1>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

extern crate m;

use m::Float;
use pg::time::Instant;
use pg::{delay, lsm303dlhc};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    use pg::time::FREQUENCY as SECONDS;

    const SENSITIVITY: f32 = 8. / ((1 &lt;&lt; 15) as f32);
    const THRESHOLD: f32 = 0.5;
    const MEASUREMENT_TIME: u32 = 1 * SECONDS;

    let mut instant = None;
    let mut max_g = 0f32;
    loop {
        let g_x = (f32::from(lsm303dlhc::acceleration().x) * SENSITIVITY).abs();

        match instant {
            None =&gt; {
                // If acceleration goes above a threshold, we start measuring
                if g_x &gt; THRESHOLD {
                    iprintln!(&quot;START!&quot;);

                    max_g = g_x;
                    instant = Some(Instant::now());
                }
            }
            // Still measuring
            Some(ref instant) if instant.elapsed() &lt; MEASUREMENT_TIME =&gt; {
                if g_x &gt; max_g {
                    max_g = g_x;
                }
            }
            _ =&gt; {
                // Report max value
                iprintln!(&quot;Max acceleration: {}g&quot;, max_g);

                // Measurement done
                instant = None;

                // Reset
                max_g = 0f32;
            }
        }

        delay::ms(50);
    }
}
</code></pre>
<h1>Async IO: The future</h1>
<blockquote>
<p><strong>WARNING</strong> Experimental code ahead!</p>
</blockquote>
<p>So far, all the high level APIs we have been using have been of the blocking
variety. For example, the <code>delay::ms</code> function makes the processor wait for some
time to pass and during that wait the processor can't perform any useful action.
That's just wasteful. These blocking APIs make it hard (or near impossible) to
write programs that have to &quot;do more than a thing&quot;.</p>
<p>The goal of this section will be to write a program that performs two concurrent
tasks: the &quot;echo server&quot; we wrote in section 10 and the LED roulette we wrote in
section 4.</p>
<p>To do that we'll have to throw away the high level APIs we have been using. The
&quot;busy&quot; waiting pattern (<code>while !condition {}</code>) we have been using must go as
well.</p>
<p>Instead we'll be using a new API based on &quot;futures&quot;. We won't be used the
<code>futures</code> crate that's available in crates.io but a minimal version of the
trait:</p>
<pre><code class="language-rust">/// Trait for types which are a placeholder of a value that will become
/// available at possible some later point in time.
trait Future {
    type Item;

    /// Check if this future has completed
    fn poll(&amp;mut self) -&gt; Async&lt;Self::Item&gt;;

    /// Drive a future to its completion by continuously calling `poll`
    fn wait(mut self) -&gt; Self::Item
        where Self: Sized
    {
        loop {
            if let Async::Ready(item) = self.poll() {
                return item;
            }
        }
    }
}

/// Return type of future, indicating whether a value is ready or not.
enum Async&lt;T&gt; {
    NotReady,
    Ready(T),
}
</code></pre>
<h1>Timer</h1>
<p>The first API we'll rediscover is <code>Timer</code> which deprecates the <code>delay</code> module.</p>
<p>Here's an example of this API.</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

use core::iter;

use pg::led::LEDS;
use pg::{Async, Future, Timer};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let mut timer = Timer::new().unwrap();

    let mut periodic = timer.periodic(100);
    let mut leds = LEDS.iter()
        .zip(LEDS.iter().skip(1))
        .chain(iter::once((&amp;LEDS[7], &amp;LEDS[0])))
        .cycle();
    loop {
        if let Async::Ready(()) = periodic.poll() {
            if let Some((current, next)) = leds.next() {
                current.off();
                next.on();
            }
        }
    }
}
</code></pre>
<p>The first thing you notice is that we need to create an instance of <code>Timer</code> to
be able to generate delays. <code>Timer::new</code> will create a unique instance of the
timer and thus will return <code>Some</code> only the first time is called; subsequent
calls of this constructor will return <code>None</code>. We'll return to this requirement
of uniqueness later on.</p>
<p><code>Timer</code> provides a <code>periodic</code> method that returns an implementer of the <code>Future</code>
trait: <code>Periodic</code>. Polling <code>Periodic</code> will return <code>Async::Ready</code> only after the
requested timeout period, 500 milliseconds in this case, has elapsed.</p>
<p><code>Periodic</code> also happens to be an &quot;infinite stream&quot; because it can yield an
infinite number of <code>Async::Ready</code> values.</p>
<p><code>Timer</code> provides another method, <code>oneshot</code>. Which can be used to emulate the old
<code>delay</code> module. In fact, <code>timer.oneshot(100).wait()</code> is equivalent to the
<code>delay::ms</code> function because it also uses busy waiting to block for 100
milliseconds.</p>
<p>The <code>oneshot</code> method actually returns a <code>Future</code> implementer, <code>OneShot</code>, which
can be used in an asynchronous manner as well. This actually means that this
asynchronous API is a super set of the synchronous one because the synchronous
behavior can be easily achieved using the <code>wait</code> method.</p>
<p>Back to the issue of uniqueness. <code>Timer</code> uses the <code>TIM7</code> peripheral under the
hood. If we allowed creation of multiple instances of it, that would make code
like this compile:</p>
<pre><code>let mut timer1 = Timer::new();
let mut timer2 = Timer::new();

let delay1 = timer.oneshot(100);
let delay2 = timer.oneshot(200);

delay1.wait();  // this actually blocks for 200 milliseconds!
</code></pre>
<p>But this won't work as expected because the second <code>oneshot</code> call will
&quot;overwrite&quot; the previous <code>oneshot</code> call as both of these methods would end
up writing to the same registers.</p>
<h1>Serial</h1>
<p>The second API we'll rediscover is <code>Serial</code> which replaces our old code that
involved direct register manipulation and busy waiting.</p>
<p>Here's an example of this API.</p>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate pg;

use pg::{Async, Future, Serial};

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let Serial { mut rx, mut tx } = Serial::new().unwrap();

    let mut bytes = rx.bytes();
    loop {
        if let Async::Ready(byte) = bytes.poll() {
            // immediately echo back the byte we just received
            tx.write(byte).wait();
        }
    }
}
</code></pre>
<p><code>Serial</code> contains two fields: <code>Rx</code> and <code>Tx</code> which provide an asynchronous API
over the receiver and transmitter parts of the serial interface.</p>
<p>One of <code>Rx</code> methods is <code>bytes</code> which returns a <code>Bytes</code> struct that represents an
infinite stream of bytes that are read from the receiver pin/line. The next byte
can be requested without blocking using the <code>poll</code> method.</p>
<p><code>Tx</code> provides a <code>write</code> method that <em>queues</em> a write onto the TX line. The write
is not performed immediately because there may be pending write. <code>wait</code> can be
used to force the write; this may involve waiting for a pending write to end.</p>
<h1>The challenge</h1>
<p>In isolation, the <code>Timer</code> and <code>Serial</code> examples I showed you are no different
that our old code that relied on busy waiting. It's when you use them together
where you can see the usefulness of using an async API.</p>
<p>Your task is to merge the two previous into one and make the echo server and the
LED roulette run concurrently.</p>
<p>Have fun!</p>
<h1>My solution</h1>
<pre><code class="language-rust">pub extern &quot;C&quot; fn main() -&gt; ! {
    let mut timer = Timer::new().unwrap();
    let Serial { tx, rx } = Serial::new().unwrap();

    let mut periodic = timer.periodic(100);
    let mut bytes = rx.bytes();
    let mut leds = LEDS.iter()
        .zip(LEDS.iter().skip(1))
        .chain(iter::once((&amp;LEDS[7], &amp;LEDS[0])))
        .cycle();

    loop {
        if let Async::Ready(()) = periodic.poll() {
            if let Some((current, next)) = leds.next() {
                current.off();
                next.on();
            }
        }

        if let Async::Ready(byte) = bytes.poll() {
            tx.write(byte).wait();
        }
    }
}
</code></pre>
<h1>Another challenge</h1>
<p>Let's increase the difficulty level.</p>
<p>Get rid of the echo server but every time the user sends the string <code>&quot;reverse&quot;</code>
reverse &quot;spin&quot; direction of the the LED roulette.</p>
<h1>My other solution</h1>
<pre><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[macro_use]
extern crate fixedvec;

#[macro_use]
extern crate pg;

use core::ops::Not;

use fixedvec::FixedVec;
use pg::{Async, Future, Serial, Timer};
use pg::led::LEDS;

#[export_name = &quot;main&quot;]
#[inline(never)]
pub extern &quot;C&quot; fn main() -&gt; ! {
    let mut timer = Timer::new().unwrap();
    let Serial { mut rx, .. } = Serial::new().unwrap();

    let mut periodic = timer.periodic(100);
    let mut bytes = rx.bytes();

    let mut memory = alloc_stack!([u8; 32]);
    let mut buffer = FixedVec::new(&amp;mut memory);
    let mut direction = Direction::Clockwise;
    let mut state = 0;
    loop {
        if let Async::Ready(()) = periodic.poll() {
            match direction {
                Direction::Clockwise =&gt; {
                    if state == 7 {
                        LEDS[state].off();
                        LEDS[0].on();

                        state = 0;
                    } else {
                        LEDS[state].off();
                        LEDS[state+1].on();

                        state += 1;
                    }
                }
                Direction::Counterclockwise =&gt; {
                    if state == 0 {
                        LEDS[state].off();
                        LEDS[7].on();

                        state = 7;
                    } else {
                        LEDS[state].off();
                        LEDS[state-1].on();

                        state -= 1;
                    }
                }
            }
        }

        if let Async::Ready(byte) = bytes.poll() {
            if let Err(_) = buffer.push(byte) {
                // TODO report error
                buffer.clear();
            } else if byte == '\r' as u8 {
                if buffer.as_slice() == b&quot;reverse\r&quot; {
                    direction = !direction;
                }

                buffer.clear();
            }
        }
    }
}

enum Direction {
    Clockwise,
    Counterclockwise,
}

impl Not for Direction {
    type Output = Self;

    fn not(self) -&gt; Self {
        match self {
            Direction::Clockwise =&gt; Direction::Counterclockwise,
            Direction::Counterclockwise =&gt; Direction::Clockwise,
        }
    }
}
</code></pre>
<h1>More challenges</h1>
<ul>
<li>Respond <code>&quot;OK&quot;</code> every time the spin direction of the LED roulette is changed.</li>
<li>Bring back the echo server. The <code>&quot;reverse&quot;</code> command must still work tough.</li>
<li>Print back an error message when your receive buffer gets full.</li>
</ul>
<h1>What's left for you to explore</h1>
<p>We have barely scratched the surface! There's lots of stuff left for you to
explore:</p>
<h2>Direct Memory Access (DMA).</h2>
<p>This peripheral is a kind of <em>asynchronous</em> <code>memcpy</code>. So far our programs have
been pumping data, byte by byte, into peripherals like UART and I2C. This DMA
peripheral can be used to perform bulk transfers of data. Either from RAM to
RAM, from a peripheral, like a UART, to RAM or from RAM to a peripheral. You can
schedule a DMA transfer, like read 256 bytes from USART1 into this buffer, leave
it running in the background and then poll some register to see if it has
completed so you can do other stuff while the transfer is ongoing.</p>
<h2>Sleeping</h2>
<p>All our programs have been continuously polling peripherals to see if there's
anything that needs to be done. However, some times there's nothing to be done!
At those times, the microcontroller should &quot;sleep&quot;.</p>
<p>When the processor sleeps, it stops executing instructions and this saves power.
It's almost always a good idea to save power so your microcontroller should be
sleeping as much as possible. But, how does it know when it has to wake up to
perform some action? &quot;Interrupts&quot; are one of the events that wake up the
microcontroller but there are others and the <code>wfi</code> and <code>wfe</code> are the
instructions that make the processor &quot;sleep&quot;.</p>
<h2>Pulse Width Modulation (PWM)</h2>
<p>In a nutshell, PWM is turning on something and then turning it off periodically
while keeping some proportion (&quot;duty cycle&quot;) between the &quot;on time&quot; and the &quot;off
time&quot;. When used on a LED with a sufficiently high frequency, this can be used
to dim the LED. A low duty cycle, say 10% on time and 90% off time, will make
the LED very dim wheres a high duty cycle, say 90% on time and 10% off time,
will make the LED much brighter (almost as if it were fully powered).</p>
<p>In general, PWM can be used to control how much <em>power</em> is given to some
electric device. With proper (power) electronics between a microcontroller and
an electrical motor, PWM can be used to control how much power is given to the
motor thus it can be used to control its torque and speed. Then you can add an
angular position sensor and you got yourself a closed loop controller that can
control the position of the motor at different loads.</p>
<h2>Digital input</h2>
<p>We have used the microcontroller pins as digital outputs, to drive LEDs. But
these pins can also be configured as digital inputs. As digital inputs, these
pins can read the binary state of switches (on/off) or buttons (pressed/not
pressed).</p>
<p>(<em>spoilers</em> reading the binary state of switches / buttons is not as
straightforward as it sounds ;-)</p>
<h2>Sensor fusion</h2>
<p>The STM32F3DISCOVERY contains three motion sensors: an accelerometer, a
gyroscope and a magnetometer. On their own these measure: (proper) acceleration,
angular speed and (the Earth's) magnetic field. But these magnitudes can be
&quot;fused&quot; into something more useful: a &quot;robust&quot; measurement of the orientation of
the board. Where robust means with less measurement error than a single sensor
would be capable of.</p>
<p>This idea of deriving more reliable data from different sources is known as
sensor fusion.</p>
<h2>Analog-to-Digital Converters (ADC)</h2>
<p>There are a lots of digital sensors out there. You can use a protocol like I2C
and SPI to read them. But analog sensors also exist! These sensors just output a
voltage level that's proportional to the magnitude they are sensing.</p>
<p>The ADC peripheral can be use to convert that &quot;analog&quot; voltage level, say <code>1.25</code>
Volts,into a &quot;digital&quot; number, say in the <code>[0, 65535]</code> range, that the processor
can use in its calculations.</p>
<h2>Digital-to-Analog Converters (DAC)</h2>
<p>As you might expect a DAC is exactly the opposite of ADC. You can write some
digital value into a register to produce a voltage in the <code>[0, 3.3V]</code> range
(assuming a <code>3.3V</code> power supply) on some &quot;analog&quot; pin. When this analog pin is
connected to some appropriate electronics and the register is written to at some
constant, fast rate (frequency) with the right values you can produce sounds or
even music!</p>
<h2>Real Time Clock (RTC)</h2>
<p>This peripheral can be used to track time in &quot;human format&quot;. Seconds, minutes,
hours, days, months and years. This peripheral handles the translation from
&quot;ticks&quot; to these human friendly units of time. It even handles leap years and
Daylight Save Time for you!</p>
<h2>Other communication protocols</h2>
<p>SPI, I2S, SMBUS, CAN, IrDA, Ethernet, USB, Bluetooth, etc.</p>
<p>Different applications use different communication protocols. User facing
applications usually have an USB connector because USB is an ubiquitous
protocol in PCs and smartphones. Whereas inside cars you'll find plenty of CAN
&quot;buses&quot;. Some digital sensors use SPI, others use I2C and others, SMBUS.
Etcetera.</p>
<h1>General troubleshooting</h1>
<h2>OpenOCD problems</h2>
<h3>can't connect to OpenOCD - &quot;Error: open failed&quot;</h3>
<h4>Symptoms</h4>
<p>Upon trying to establish a <em>new connection</em> with the device you get an error
that looks like this:</p>
<pre><code>$ openocd -f (..)
(..)
Error: open failed
in procedure 'init'
in procedure 'ocd_bouncer'
</code></pre>
<h4>Cause + Fix</h4>
<ul>
<li>All: The device is not (properly) connected. Check the USB connection using
<code>lsusb</code> or the Device Manager.</li>
<li>Linux: You may not have enough permission to open the device. Try again with
<code>sudo</code>. If that works, you can use <a href="01-installation-instructions/linux.html#udev%20rules">these instructions</a> to make OpenOCD work
without root privilege.</li>
<li>Windows: You are probably missing the ST-LINK USB driver. Installation
instructions <a href="01-installation-instructions/windows.html#ST-LINK%20USB%20driver">here</a>.</li>
</ul>
<h3>can't connect to OpenOCD - &quot;Polling again in X00ms&quot;</h3>
<h4>Symptoms</h4>
<p>Upon trying to establish a <em>new connection</em> with the device you get an error
that looks like this:</p>
<pre><code>$ openocd -f (..)
(..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<h4>Cause</h4>
<p>The microcontroller may have get stuck in some tight infinite loop or it may be
continuously raising an exception, e.g. the exception handler is raising an
exception.</p>
<h4>Fix</h4>
<ul>
<li>Close OpenOCD, if running</li>
<li>Press and hold the reset (black) button</li>
<li>Launch the OpenOCD command</li>
<li>Now, release the reset button</li>
</ul>
<h3>OpenOCD connection lost - &quot;Polling again in X00ms&quot;</h3>
<h4>Symptoms</h4>
<p>A <em>running</em> OpenOCD session suddenly errors with:</p>
<pre><code># openocd -f (..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<h4>Cause</h4>
<p>The USB connection was lost.</p>
<h4>Fix</h4>
<ul>
<li>Close OpenOCD</li>
<li>Disconnect and re-connect the USB cable.</li>
<li>Re-launch OpenOCD</li>
</ul>
<h3>Can't flash the device - &quot;Ignoring packet error, continuing...&quot;</h3>
<h4>Symptoms</h4>
<p>While flashing the device, you get:</p>
<pre><code>$ arm-none-eabi-gdb $file
Start address 0x8000194, load size 31588
Transfer rate: 22 KB/sec, 5264 bytes/write.
Ignoring packet error, continuing...
Ignoring packet error, continuing...
</code></pre>
<h4>Cause</h4>
<p>Closed <code>itmdump</code> while a program that &quot;printed&quot; to the ITM was running. The
current GDB session will appear to work normally, just without ITM output but
the next GDB session will error with the message that was shown in the previous
section.</p>
<p>Or, <code>itmdump</code> was called <strong>after</strong> the <code>monitor tpiu</code> was issued thus making
<code>itmdump</code> delete the file / named-pipe that OpenOCD was writing to.</p>
<h4>Fix</h4>
<ul>
<li>Close/kill GDB, OpenOCD and <code>itmdump</code></li>
<li>Remove the file / named-pipe that <code>itmdump</code> was using (for example,
<code>itm.txt</code>).</li>
<li>Launch OpenOCD</li>
<li>Then, launch <code>itmdump</code></li>
<li>Then, launch the GDB session that executes the <code>monitor tpiu</code> command.</li>
</ul>
<h2>Cargo problems</h2>
<h3>&quot;can't find crate for <code>core</code>&quot;</h3>
<h4>Symptoms</h4>
<pre><code>   Compiling volatile-register v0.1.2
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
Build failed, waiting for other jobs to finish...
error: Could not compile `r0`.

To learn more, run the command again with --verbose.
</code></pre>
<h4>Cause</h4>
<p>You are probably using <code>cargo</code> instead of <code>xargo</code>.</p>
<h4>Fix</h4>
<p>Use Xargo instead of Cargo!</p>
<pre><code>$ xargo build --target thumbv7em-none-eabihf
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
